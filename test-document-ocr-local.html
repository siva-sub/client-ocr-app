<!DOCTYPE html>
<html>
<head>
    <title>Document OCR Test - Local Only</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            background: #f5f5f5;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .section {
            background: white;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #preview {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #results {
            white-space: pre-wrap;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            max-height: 600px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #0056b3;
        }
        .doc-type-buttons {
            margin: 10px 0;
        }
        .doc-type-buttons button {
            background: #6c757d;
        }
        .doc-type-buttons button.active {
            background: #28a745;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .info { background: #d1ecf1; color: #0c5460; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .field-results {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        .field-item {
            margin: 5px 0;
            padding: 5px;
            background: white;
            border-radius: 3px;
        }
        .field-label {
            font-weight: bold;
            color: #495057;
            display: inline-block;
            width: 150px;
        }
        .field-value {
            color: #212529;
        }
    </style>
</head>
<body>
    <h1>Document OCR Test - Local Testing Only</h1>
    
    <div class="warning">
        ⚠️ <strong>Privacy Notice:</strong> This is for local testing only. 
        Do NOT upload personal documents to any public repository. 
        All processing happens in your browser.
    </div>
    
    <div class="controls">
        <h3>1. Select Document Type:</h3>
        <div class="doc-type-buttons">
            <button id="generalBtn" class="doc-type active" data-type="general">General Document</button>
            <button id="idcardBtn" class="doc-type" data-type="idcard">ID Card</button>
            <button id="bankingBtn" class="doc-type" data-type="banking">Banking Document</button>
        </div>
        
        <h3>2. Select Image:</h3>
        <input type="file" id="fileInput" accept="image/*" multiple>
        
        <h3>3. Process:</h3>
        <button id="processStandardBtn">Process with Standard OCR</button>
        <button id="processOptimizedBtn">Process with Document Optimization</button>
        <button id="compareBtn">Compare Both Methods</button>
    </div>
    
    <div id="status" class="status info">Ready to process documents</div>
    
    <div class="container">
        <div class="section">
            <h2>Original Image</h2>
            <img id="preview" />
            <div id="imageInfo" style="margin-top: 10px; color: #666;"></div>
        </div>
        <div class="section">
            <h2>OCR Results</h2>
            <div id="results">No results yet</div>
            <div id="fieldResults" class="field-results" style="display: none;">
                <h3>Extracted Fields:</h3>
                <div id="fieldsList"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { ppOCRImprovedEngine } from './src/ppocr-improved-engine.js';
        import { tesseractOCREngine } from './src/tesseract-ocr-engine.js';
        import { 
            DOCUMENT_OCR_CONFIG, 
            updatePaddleOCRForDocuments, 
            preprocessDocument,
            extractIDCardFields 
        } from './src/document-ocr-config.js';
        
        let currentImage = null;
        let currentDocType = 'general';
        let currentFiles = [];
        let currentFileIndex = 0;
        
        // Initialize OCR engines
        async function initializeOCR() {
            setStatus('Initializing OCR engines...', 'info');
            try {
                // Initialize both engines
                await Promise.all([
                    ppOCRImprovedEngine.initialize((progress) => {
                        console.log('PaddleOCR:', progress.message);
                    }),
                    tesseractOCREngine.initialize((progress) => {
                        console.log('Tesseract:', progress.message);
                    })
                ]);
                setStatus('OCR engines ready!', 'success');
            } catch (error) {
                setStatus('Failed to initialize OCR: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        // Document type selection
        document.querySelectorAll('.doc-type').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.doc-type').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentDocType = e.target.dataset.type;
                setStatus(`Document type set to: ${currentDocType}`, 'info');
            });
        });
        
        // Handle file selection
        document.getElementById('fileInput').addEventListener('change', (e) => {
            currentFiles = Array.from(e.target.files);
            currentFileIndex = 0;
            if (currentFiles.length > 0) {
                loadFile(currentFiles[0]);
            }
        });
        
        function loadFile(file) {
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    currentImage = e.target.result;
                    document.getElementById('preview').src = currentImage;
                    
                    // Show image info
                    const img = new Image();
                    img.onload = () => {
                        document.getElementById('imageInfo').textContent = 
                            `${file.name} - ${img.width}x${img.height} pixels`;
                    };
                    img.src = currentImage;
                    
                    setStatus(`Image loaded: ${file.name}. Ready to process.`, 'success');
                };
                reader.readAsDataURL(file);
            }
        }
        
        // Process with standard configuration
        document.getElementById('processStandardBtn').addEventListener('click', async () => {
            if (!currentImage) {
                setStatus('Please select an image first', 'error');
                return;
            }
            
            setStatus('Processing with standard configuration...', 'info');
            const startTime = Date.now();
            
            try {
                const response = await fetch(currentImage);
                const blob = await response.blob();
                
                // Use Tesseract for standard processing
                const results = await tesseractOCREngine.process(blob);
                
                const elapsed = Date.now() - startTime;
                displayResults(results, elapsed, 'Standard OCR (Tesseract)', false);
                setStatus(`Processing complete in ${elapsed}ms`, 'success');
            } catch (error) {
                setStatus('Processing failed: ' + error.message, 'error');
                console.error(error);
            }
        });
        
        // Process with document optimization
        document.getElementById('processOptimizedBtn').addEventListener('click', async () => {
            if (!currentImage) {
                setStatus('Please select an image first', 'error');
                return;
            }
            
            setStatus(`Processing with ${currentDocType} document optimization...`, 'info');
            const startTime = Date.now();
            
            try {
                // Apply document-specific configuration
                updatePaddleOCRForDocuments(ppOCRImprovedEngine, currentDocType);
                
                const response = await fetch(currentImage);
                const blob = await response.blob();
                
                // Process with PaddleOCR
                const results = await ppOCRImprovedEngine.process(blob);
                
                const elapsed = Date.now() - startTime;
                displayResults(results, elapsed, `Optimized OCR (${currentDocType})`, true);
                setStatus(`Processing complete in ${elapsed}ms`, 'success');
            } catch (error) {
                setStatus('Processing failed: ' + error.message, 'error');
                console.error(error);
            }
        });
        
        // Compare both methods
        document.getElementById('compareBtn').addEventListener('click', async () => {
            if (!currentImage) {
                setStatus('Please select an image first', 'error');
                return;
            }
            
            setStatus('Comparing both OCR methods...', 'info');
            
            try {
                const response = await fetch(currentImage);
                const blob = await response.blob();
                
                // Process with standard
                const startStandard = Date.now();
                const standardResults = await tesseractOCREngine.process(blob);
                const standardTime = Date.now() - startStandard;
                
                // Process with optimized
                updatePaddleOCRForDocuments(ppOCRImprovedEngine, currentDocType);
                const startOptimized = Date.now();
                const optimizedResults = await ppOCRImprovedEngine.process(blob);
                const optimizedTime = Date.now() - startOptimized;
                
                // Display comparison
                displayComparison(standardResults, optimizedResults, standardTime, optimizedTime);
                setStatus('Comparison complete', 'success');
            } catch (error) {
                setStatus('Comparison failed: ' + error.message, 'error');
                console.error(error);
            }
        });
        
        // Display results
        function displayResults(results, processingTime, method, showFields) {
            const resultsDiv = document.getElementById('results');
            const fieldResultsDiv = document.getElementById('fieldResults');
            
            if (!results || results.length === 0) {
                resultsDiv.textContent = 'No text detected';
                fieldResultsDiv.style.display = 'none';
                return;
            }
            
            let output = `=== ${method} Results ===\n`;
            output += `Processing Time: ${processingTime}ms\n`;
            output += `Text Regions Found: ${results.length}\n\n`;
            
            // Sort and group results
            const sortedResults = sortResults(results);
            const groupedText = groupResultsByLine(sortedResults);
            
            output += '=== Extracted Text (Grouped by Line) ===\n';
            groupedText.forEach(line => {
                output += line + '\n';
            });
            
            output += '\n=== All Detected Regions ===\n';
            sortedResults.forEach((result, index) => {
                const confidence = result.confidence ? (result.confidence * 100).toFixed(1) : 'N/A';
                output += `[${index + 1}] "${result.text}" (confidence: ${confidence}%)\n`;
            });
            
            resultsDiv.textContent = output;
            
            // Extract fields for ID cards
            if (showFields && currentDocType === 'idcard') {
                const fields = extractIDCardFields(sortedResults);
                displayFields(fields);
                fieldResultsDiv.style.display = 'block';
            } else {
                fieldResultsDiv.style.display = 'none';
            }
        }
        
        // Sort results by position
        function sortResults(results) {
            return [...results].sort((a, b) => {
                const aY = a.box ? Math.min(...a.box.map(p => p[1])) : a.bbox ? a.bbox.y0 : 0;
                const bY = b.box ? Math.min(...b.box.map(p => p[1])) : b.bbox ? b.bbox.y0 : 0;
                const aX = a.box ? Math.min(...a.box.map(p => p[0])) : a.bbox ? a.bbox.x0 : 0;
                const bX = b.box ? Math.min(...b.box.map(p => p[0])) : b.bbox ? b.bbox.x0 : 0;
                
                if (Math.abs(aY - bY) < 20) {
                    return aX - bX;
                }
                return aY - bY;
            });
        }
        
        // Group results by line
        function groupResultsByLine(results) {
            const lines = [];
            let currentLine = [];
            let lastY = -1;
            
            results.forEach(result => {
                const y = result.box ? Math.min(...result.box.map(p => p[1])) : 
                         result.bbox ? result.bbox.y0 : 0;
                
                if (lastY !== -1 && Math.abs(y - lastY) > 30) {
                    if (currentLine.length > 0) {
                        lines.push(currentLine.join(' '));
                        currentLine = [];
                    }
                }
                
                currentLine.push(result.text);
                lastY = y;
            });
            
            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }
            
            return lines;
        }
        
        // Display extracted fields
        function displayFields(fields) {
            const fieldsList = document.getElementById('fieldsList');
            fieldsList.innerHTML = '';
            
            Object.entries(fields).forEach(([key, value]) => {
                if (value) {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'field-item';
                    fieldDiv.innerHTML = `
                        <span class="field-label">${formatFieldName(key)}:</span>
                        <span class="field-value">${value}</span>
                    `;
                    fieldsList.appendChild(fieldDiv);
                }
            });
        }
        
        // Format field names
        function formatFieldName(fieldName) {
            return fieldName
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase())
                .trim();
        }
        
        // Display comparison
        function displayComparison(standardResults, optimizedResults, standardTime, optimizedTime) {
            const resultsDiv = document.getElementById('results');
            
            let output = '=== OCR COMPARISON RESULTS ===\n\n';
            
            // Timing comparison
            output += `Standard OCR: ${standardTime}ms | Optimized OCR: ${optimizedTime}ms\n`;
            output += `Speed improvement: ${((standardTime - optimizedTime) / standardTime * 100).toFixed(1)}%\n\n`;
            
            // Results comparison
            output += `Standard found: ${standardResults.length} regions\n`;
            output += `Optimized found: ${optimizedResults.length} regions\n\n`;
            
            // Text comparison
            const standardText = groupResultsByLine(sortResults(standardResults)).join('\n');
            const optimizedText = groupResultsByLine(sortResults(optimizedResults)).join('\n');
            
            output += '=== STANDARD OCR TEXT ===\n';
            output += standardText + '\n\n';
            
            output += '=== OPTIMIZED OCR TEXT ===\n';
            output += optimizedText + '\n\n';
            
            // Differences
            output += '=== UNIQUE TO OPTIMIZED ===\n';
            const optimizedLines = optimizedText.split('\n');
            const standardLines = standardText.split('\n');
            
            optimizedLines.forEach(line => {
                if (!standardLines.some(sLine => sLine.includes(line) || line.includes(sLine))) {
                    output += '+ ' + line + '\n';
                }
            });
            
            resultsDiv.textContent = output;
        }
        
        // Set status message
        function setStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Initialize on load
        window.addEventListener('load', initializeOCR);
    </script>
</body>
</html>