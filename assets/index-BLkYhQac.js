import{b as ce,F as me,H as fe}from"./onnxruntime-CqRzMC93.js";import{p as Q,c as ke,g as Ye}from"./pdfjs-BhC3vFUT.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function t(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(o){if(o.ep)return;o.ep=!0;const i=t(o);fetch(o.href,i)}})();Q.GlobalWorkerOptions.workerSrc="/client-ocr-app/pdf.worker.min.js";ce.wasm.wasmPaths="/client-ocr-app/assets/";ce.wasm.numThreads=1;ce.webgl.pack=!1;ce.webgl.matmulMaxBatchSize=16;const ye="/client-ocr-app/models/",F={det_limit_side_len:1280,det_limit_type:"max",det_db_thresh:.05,det_db_box_thresh:.1,det_db_unclip_ratio:2.5,det_db_min_size:2,det_db_max_candidates:2e3,det_use_dilation:!0,det_dilation_kernel:3,rec_image_height:48,rec_image_width:320,rec_batch_num:6,drop_score:.05,det_mean:[.485,.456,.406],det_std:[.229,.224,.225],rec_mean:.5,rec_std:.5,min_area_thresh:2,vertical_gap_threshold:.5,english_mode:!0,min_word_confidence:.1,enable_word_splitting:!0,grid_size:16,overlap_ratio:.2};class He{constructor(){this.detectionSession=null,this.recognitionSession=null,this.charDict=[],this.initialized=!1,this.canvas=null,this.ctx=null,this.modelConfig={detection:"PP-OCRv5_mobile_det_infer.onnx",recognition:"en_PP-OCRv4_mobile_rec_infer.onnx",dictionary:"en_dict.txt"}}setModelConfig(e){e.detection&&(this.modelConfig.detection=e.detection),e.recognition&&(this.modelConfig.recognition=e.recognition),e.dictionary&&(this.modelConfig.dictionary=e.dictionary),this.initialized=!1}async initialize(e){try{this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),e==null||e({status:"loading",message:"Loading dictionary...",progress:10}),await this.loadDictionary();const t=this.modelConfig.detection.replace(".onnx","").replace(/_/g," ");e==null||e({status:"loading",message:`Loading ${t}...`,progress:30}),this.detectionSession&&await this.detectionSession.release();const n=["webgl","wasm"];let o=null;for(const r of n)try{console.log(`Trying to load detection model with ${r} provider...`),this.detectionSession=await me.create(ye+this.modelConfig.detection,{executionProviders:[r],graphOptimizationLevel:"all",enableCpuMemArena:!1,enableMemPattern:!1}),console.log(`Detection model loaded successfully with ${r}:`,this.detectionSession.inputNames,this.detectionSession.outputNames);break}catch(l){if(console.warn(`Failed to load with ${r}:`,l.message),o=l,r===n[n.length-1])throw o}const i=this.modelConfig.recognition.replace(".onnx","").replace(/_/g," ");e==null||e({status:"loading",message:`Loading ${i}...`,progress:70}),this.recognitionSession&&await this.recognitionSession.release();for(const r of n)try{console.log(`Trying to load recognition model with ${r} provider...`),this.recognitionSession=await me.create(ye+this.modelConfig.recognition,{executionProviders:[r],graphOptimizationLevel:"all",enableCpuMemArena:!1,enableMemPattern:!1}),console.log(`Recognition model loaded successfully with ${r}:`,this.recognitionSession.inputNames,this.recognitionSession.outputNames);break}catch(l){if(console.warn(`Failed to load recognition with ${r}:`,l.message),o=l,r===n[n.length-1])throw o}this.initialized=!0,e==null||e({status:"ready",message:"PP-OCR ready!",progress:100})}catch(t){throw console.error("Failed to initialize PP-OCR models:",t),t}}async loadDictionary(){try{const t=await(await fetch(ye+this.modelConfig.dictionary)).text();this.charDict=t.split(`
`).filter(n=>n.trim()),this.charDict.unshift(" "),console.log(`Loaded dictionary ${this.modelConfig.dictionary} with ${this.charDict.length} characters`)}catch(e){console.error("Failed to load dictionary:",e),this.charDict=[" "];for(let t=32;t<127;t++)this.charDict.push(String.fromCharCode(t))}}async process(e){if(!this.initialized)throw new Error("OCR engine not initialized");if(console.log("Processing blob type:",e.type,"size:",e.size),e.type==="application/pdf")return await this.processPDF(e);console.log("Converting blob to image...");const t=await this.blobToImage(e);console.log("Image loaded:",t.width,"x",t.height);const n=await this.detectText(t),o=await this.recognizeText(t,n);return this.mergeTextLines(o)}async detectText(e){var t,n;if(console.log("detectText called, checking detection session..."),!this.detectionSession)throw new Error("Detection model not loaded");console.log("Detection session exists:",this.detectionSession),console.log("Current dictionary:",this.modelConfig.dictionary,"Dictionary length:",this.charDict.length);try{console.log("Starting image resize...");const{resizedImage:o,ratio:i}=await this.resizeForDetection(e);console.log("Image resized, ratio:",i),console.log("Starting preprocessing...");const r=await this.preprocessForDetection(o);console.log("Preprocessing complete, tensor shape:",r.dims),console.log("Running detection model..."),console.log("Input names:",this.detectionSession.inputNames),console.log("Output names:",this.detectionSession.outputNames);const l={[this.detectionSession.inputNames[0]]:r};let s;try{console.log("Tensor data type:",r.type),console.log("Tensor size:",r.data.length),console.log("Tensor shape:",r.dims),console.log("Expected input name:",this.detectionSession.inputNames[0]);try{const v=this.detectionSession.inputNames.map(L=>({name:L}));console.log("Model inputs:",v)}catch{console.log("Could not get model input info")}const h=r.data;let c=0,u=0,g=1/0,y=-1/0;for(let v=0;v<h.length;v++)isNaN(h[v])&&c++,isFinite(h[v])||u++,g=Math.min(g,h[v]),y=Math.max(y,h[v]);console.log(`Tensor stats: min=${g.toFixed(3)}, max=${y.toFixed(3)}`),(c>0||u>0)&&console.error(`Invalid tensor data: ${c} NaN values, ${u} Inf values`),s=await this.detectionSession.run(l),console.log("Detection complete"),console.log("Output shape:",s[this.detectionSession.outputNames[0]].dims)}catch(h){if(console.error("ONNX inference error:",h),console.error("Error code:",h.code),console.error("Error message:",h.message),console.error("Error stack:",h.stack),h.code===30757872||(t=h.message)!=null&&t.includes("invalid graph")||(n=h.message)!=null&&n.includes("dimension mismatch")){console.error("Model compatibility issue detected. The model might require specific input dimensions."),console.error("Trying simplified approach...");try{const c=await this.simplifiedDetection(o,i);return console.log(`Simplified detection found ${c.length} regions`),c}catch(c){console.error("Simplified detection also failed:",c)}}throw h}const d=await this.postprocessDetection(s[this.detectionSession.outputNames[0]],o.width,o.height,i);return console.log(`Detected ${d.length} text regions`),this.sortBoxes(d)}catch(o){return console.error("Error in detectText:",o),console.error("Error details:",{message:o.message,stack:o.stack,name:o.name,code:o.code}),[]}}async resizeForDetection(e){try{console.log("resizeForDetection - input image size:",e.width,"x",e.height);const t=F.det_limit_side_len,n=F.det_limit_type;let o=e.width,i=e.height,r=1;n==="max"&&Math.max(i,o)>t&&(r=i>o?t/i:t/o),o=Math.round(o*r),i=Math.round(i*r);const l=F.grid_size||32,s=Math.max(l,Math.round(o/l)*l),d=Math.max(l,Math.round(i/l)*l);if(console.log(`Resizing from ${e.width}x${e.height} to ${s}x${d} (ratio: ${r})`),s<=0||d<=0||!isFinite(s)||!isFinite(d))throw new Error(`Invalid target dimensions: ${s}x${d}`);const h=await this.preprocessImage(e,s,d),c=new Image;return new Promise(u=>{this.canvas.toBlob(g=>{const y=URL.createObjectURL(g);c.onload=()=>{URL.revokeObjectURL(y),u({resizedImage:c,ratio:r})},c.src=y})})}catch(t){throw console.error("Error in resizeForDetection:",t),t}}async preprocessImage(e,t,n){this.canvas.width=t,this.canvas.height=n,this.ctx.fillStyle="white",this.ctx.fillRect(0,0,t,n),this.ctx.imageSmoothingEnabled=!0,this.ctx.imageSmoothingQuality="high";const o=Math.min(t/e.width,n/e.height),i=e.width*o,r=e.height*o,l=(t-i)/2,s=(n-r)/2;this.ctx.drawImage(e,l,s,i,r);const d=this.ctx.getImageData(0,0,t,n),h=d.data;for(let c=0;c<h.length;c+=4){let g=(.299*h[c]+.587*h[c+1]+.114*h[c+2]-128)*1.2+128;g>240?g=255:g<15&&(g=0),g=Math.max(0,Math.min(255,g)),h[c]=g,h[c+1]=g,h[c+2]=g}return this.ctx.putImageData(d,0,0),this.canvas}async preprocessForDetection(e){try{this.canvas.width=e.width,this.canvas.height=e.height,this.ctx.drawImage(e,0,0);const n=this.ctx.getImageData(0,0,e.width,e.height).data;console.log(`Preprocessing image: ${e.width}x${e.height}`);const o=e.width*e.height,i=new Float32Array(3*o),r=F.det_mean||[.485,.456,.406],l=F.det_std||[.229,.224,.225];for(let d=0;d<o;d++){const h=d*4,c=Math.max(0,Math.min(255,n[h])),u=Math.max(0,Math.min(255,n[h+1])),g=Math.max(0,Math.min(255,n[h+2]));i[d]=(c/255-r[0])/l[0],i[o+d]=(u/255-r[1])/l[1],i[2*o+d]=(g/255-r[2])/l[2]}for(let d=0;d<i.length;d++)isFinite(i[d])||(console.error(`Invalid value at index ${d}: ${i[d]}`),i[d]=0);const s=new fe("float32",i,[1,3,e.height,e.width]);return console.log("Created tensor with shape:",s.dims,"type:",s.type),s}catch(t){throw console.error("Error in preprocessForDetection:",t),new Error(`Preprocessing failed: ${t.message}`)}}async postprocessDetection(e,t,n,o){try{let i,r,l;if(e.dims.length===4){const[b,O,I,M]=e.dims;i=I,r=M,l=e.data}else if(e.dims.length===3){const[b,O,I]=e.dims;i=O,r=I,l=e.data}else throw new Error(`Unexpected output tensor dimensions: ${e.dims}`);console.log(`Detection output shape: ${i}x${r}, total pixels: ${i*r}`),console.log("Output tensor dims:",e.dims),console.log("Data length:",l.length);const s=new Float32Array(i*r);for(let b=0;b<i*r;b++)s[b]=1/(1+Math.exp(-l[b]));const d=new Uint8Array(i*r);let h=0;for(let b=0;b<i*r;b++)d[b]=s[b]>F.det_db_thresh?255:0,d[b]===255&&h++;console.log(`Detected pixels: ${h} out of ${i*r} (${(h/(i*r)*100).toFixed(2)}%)`),console.log(`Detection threshold: ${F.det_db_thresh}`);const c=[];for(let b=0;b<Math.min(10,s.length);b+=Math.floor(s.length/10))c.push(s[b].toFixed(3));console.log("Sample probability values:",c);const u=[],g=new Set;let y=0,v=0,L=0,R=0;for(let b=0;b<i&&y<F.det_db_max_candidates;b++)for(let O=0;O<r&&y<F.det_db_max_candidates;O++){const I=b*r+O;if(d[I]===255&&!g.has(I)){const M=this.findConnectedComponent(d,r,i,O,b,g,s);if(M)if(v++,M.score>=F.det_db_box_thresh){M.points=M.points.map(C=>[Math.round(C[0]/o),Math.round(C[1]/o)]);const B=this.calculatePolygonArea(M.points);B>F.min_area_thresh?(u.push(M),y++):(R++,console.log(`Component rejected by area: ${B} < ${F.min_area_thresh}`))}else L++,console.log(`Component rejected by score: ${M.score.toFixed(3)} < ${F.det_db_box_thresh}`)}}return console.log(`Detection summary: ${v} components found, ${y} accepted, ${L} rejected by score, ${R} rejected by area`),u}catch(i){throw console.error("Error in postprocessDetection:",i),new Error(`Detection post-processing failed: ${i.message}`)}}findConnectedComponent(e,t,n,o,i,r,l){const s=[[o,i]],d=[];let h=0,c=0;const u=1e4,g=i*t+o;if(r.has(g)||e[g]!==255)return null;const y=new Set;for(y.add(g);s.length>0&&d.length<u;){const[C,D]=s.pop(),j=D*t+C;if(!r.has(j)&&(r.add(j),e[j]===255)){d.push([C,D]),h+=l[j],c++;const re=[[C,D-1],[C,D+1],[C-1,D],[C+1,D]];for(const[U,G]of re)if(U>=0&&U<t&&G>=0&&G<n){const q=G*t+U;if(!r.has(q)&&e[q]===255){const le=Math.abs(G-i),X=Math.abs(U-o);(le<n*.05||X<t*.3)&&(s.push([U,G]),y.add(q))}}}}if(d.length<F.det_db_min_size)return null;const v=d.map(C=>C[0]),L=d.map(C=>C[1]);let R=Math.min(...v),b=Math.max(...v),O=Math.min(...L),I=Math.max(...L);const M=(b-R)*.1,B=(I-O)*.2;return R=Math.max(0,R-M),b=Math.min(t-1,b+M),O=Math.max(0,O-B),I=Math.min(n-1,I+B),{points:[[R,O],[b,O],[b,I],[R,I]],score:h/c}}calculatePolygonArea(e){let t=0;const n=e.length;for(let o=0;o<n;o++){const i=(o+1)%n;t+=e[o][0]*e[i][1],t-=e[i][0]*e[o][1]}return Math.abs(t)/2}async simplifiedDetection(e,t){console.log("Using simplified detection fallback..."),this.canvas.width=e.width,this.canvas.height=e.height,this.ctx.drawImage(e,0,0);const o=this.ctx.getImageData(0,0,e.width,e.height).data,i=new Uint8Array(e.width*e.height);for(let s=0;s<i.length;s++){const d=s*4,h=.299*o[d]+.587*o[d+1]+.114*o[d+2];i[s]=h<200?255:0}const r=[],l=new Set;for(let s=10;s<e.height-10;s+=20)for(let d=10;d<e.width-10;d+=20){const h=s*e.width+d;if(i[h]===255&&!l.has(h)){let c=d,u=d,g=s,y=s;const v=[[d,s]];for(;v.length>0&&l.size<1e4;){const[L,R]=v.pop(),b=R*e.width+L;L<0||L>=e.width||R<0||R>=e.height||l.has(b)||i[b]!==255||(l.add(b),c=Math.min(c,L),u=Math.max(u,L),g=Math.min(g,R),y=Math.max(y,R),v.push([L+1,R],[L-1,R],[L,R+1],[L,R-1]))}u-c>10&&y-g>10&&r.push({points:[[c/t,g/t],[u/t,g/t],[u/t,y/t],[c/t,y/t]],score:.8})}}return r}sortBoxes(e){if(e.length===0)return e;e.sort((t,n)=>{const o=t.points[0][1],i=n.points[0][1];return o-i});for(let t=e.length-1;t>0;t--)for(let n=t-1;n>=0&&(Math.abs(e[n+1].points[0][1]-e[n].points[0][1])<10&&e[n+1].points[0][0]<e[n].points[0][0]);n--){const o=e[n];e[n]=e[n+1],e[n+1]=o}return e}async recognizeText(e,t){if(!this.recognitionSession)throw new Error("Recognition model not loaded");const n=[],o=F.rec_batch_num;for(let i=0;i<t.length;i+=o){const r=t.slice(i,Math.min(i+o,t.length)),l=await this.processBatch(e,r);n.push(...l)}return n}async processBatch(e,t){const n=[],o=[],i=[];for(const l of t){const s=await this.getRotateCropImage(e,l),d=s.width/s.height;o.push(s),i.push(d)}const r=Array.from({length:t.length},(l,s)=>s).sort((l,s)=>i[l]-i[s]);for(const l of r){const s=o[l],d=t[l],h=await this.preprocessForRecognition(s),c={[this.recognitionSession.inputNames[0]]:h},u=await this.recognitionSession.run(c),g=await this.decodeRecognition(u[this.recognitionSession.outputNames[0]]);g.score>=F.drop_score&&n.push({text:g.text,confidence:g.score,box:d.points})}return n}async getRotateCropImage(e,t){const n=t.points;Math.sqrt(Math.pow(n[0][0]-n[1][0],2)+Math.pow(n[0][1]-n[1][1],2)),Math.sqrt(Math.pow(n[2][0]-n[3][0],2)+Math.pow(n[2][1]-n[3][1],2)),Math.sqrt(Math.pow(n[0][0]-n[3][0],2)+Math.pow(n[0][1]-n[3][1],2)),Math.sqrt(Math.pow(n[1][0]-n[2][0],2)+Math.pow(n[1][1]-n[2][1],2));const o=Math.min(...n.map(c=>c[0])),i=Math.max(...n.map(c=>c[0])),r=Math.min(...n.map(c=>c[1])),l=Math.max(...n.map(c=>c[1])),s=i-o,d=l-r;if(this.canvas.width=s,this.canvas.height=d,this.ctx.drawImage(e,o,r,s,d,0,0,s,d),d*1/s>=1.5){const c=document.createElement("canvas"),u=c.getContext("2d",{willReadFrequently:!0});c.width=d,c.height=s,u.translate(d/2,s/2),u.rotate(Math.PI/2),u.drawImage(this.canvas,-s/2,-d/2),this.canvas.width=d,this.canvas.height=s,this.ctx.drawImage(c,0,0)}const h=new Image;return new Promise(c=>{this.canvas.toBlob(u=>{const g=URL.createObjectURL(u);h.onload=()=>{URL.revokeObjectURL(g),c(h)},h.src=g})})}async preprocessForRecognition(e){const n=F.rec_image_height,o=F.rec_image_width,i=e.height,l=e.width/i;let s;Math.ceil(n*l)>o?s=o:s=Math.ceil(n*l),this.canvas.width=s,this.canvas.height=n,this.ctx.fillStyle="white",this.ctx.fillRect(0,0,s,n),this.ctx.drawImage(e,0,0,s,n);const h=this.ctx.getImageData(0,0,s,n).data,c=new Float32Array(3*n*o);for(let u=0;u<3;u++)for(let g=0;g<n;g++)for(let y=0;y<s;y++){const v=(g*s+y)*4+u,L=u*n*o+g*o+y;c[L]=(h[v]/255-F.rec_mean)/F.rec_std}return new fe("float32",c,[1,3,n,o])}async decodeRecognition(e){const[t,n,o]=e.dims,i=e.data,r=[],l=[];for(let c=0;c<n;c++){let u=0,g=i[c*o];for(let y=1;y<o;y++){const v=i[c*o+y];v>g&&(g=v,u=y)}r.push(u),l.push(g)}const s=[],d=[];let h=-1;for(let c=0;c<r.length;c++){const u=r[c];u!==0&&u!==h&&u<this.charDict.length&&(s.push(this.charDict[u]),d.push(l[c])),h=u}return{text:s.join(""),score:d.length>0?d.reduce((c,u)=>c+u)/d.length:0}}mergeTextLines(e){if(e.length===0)return e;let t=this.filterResults(e);if(t.length===0)return t;t=this.postProcessEnglishText(t);const n=t.map(s=>{const d=s.box.map(h=>h[1]);return Math.max(...d)-Math.min(...d)}),o=n.reduce((s,d)=>s+d)/n.length,i=[];let r=[t[0]];for(let s=1;s<t.length;s++){const d=t[s],h=t[s-1],c=Math.min(...h.box.map(v=>v[1])),u=Math.min(...d.box.map(v=>v[1])),g=Math.abs(u-c),y=o*F.vertical_gap_threshold;g<=y?r.push(d):(i.push(r),r=[d])}r.length>0&&i.push(r);const l=[];for(const s of i){s.sort((y,v)=>{const L=Math.min(...y.box.map(b=>b[0])),R=Math.min(...v.box.map(b=>b[0]));return L-R});const d=s.map(y=>y.text).join(" "),h=s.reduce((y,v)=>y+v.confidence,0)/s.length,c=s.flatMap(y=>y.box),u=c.map(y=>y[0]),g=c.map(y=>y[1]);l.push({text:d,confidence:h,box:[[Math.min(...u),Math.min(...g)],[Math.max(...u),Math.min(...g)],[Math.max(...u),Math.max(...g)],[Math.min(...u),Math.max(...g)]]})}return l}filterResults(e){const t=F.drop_score;return e.filter(n=>n.confidence<t?!1:n.text&&n.text.trim().length>0)}async processPDF(e){const t=await e.arrayBuffer(),n=await Q.getDocument({data:t}).promise,o=n.numPages,i=[];for(let r=1;r<=o;r++){const l=await n.getPage(r),s=l.getViewport({scale:2}),d=document.createElement("canvas"),h=d.getContext("2d");d.width=s.width,d.height=s.height,await l.render({canvasContext:h,viewport:s}).promise;const c=await new Promise(g=>d.toBlob(g)),u=await this.process(c);i.push({page:r,results:u})}return i}async blobToImage(e){return new Promise((t,n)=>{const o=new Image,i=URL.createObjectURL(e);o.onload=()=>{URL.revokeObjectURL(i),t(o)},o.onerror=()=>{URL.revokeObjectURL(i),n(new Error("Failed to load image"))},o.src=i})}postProcessEnglishText(e){return e.map(t=>{let n=t.text;n=n.replace(/([a-z])([A-Z])/g,"$1 $2").replace(/([a-zA-Z])(\d)/g,"$1 $2").replace(/(\d)([a-zA-Z])/g,"$1 $2").replace(/\s+/g," ").replace(/([.,!?;:])([a-zA-Z])/g,"$1 $2").trim();const o={tne:"the",tnat:"that",wnen:"when",wnere:"where",witn:"with","l'":"I'"," l ":" I ","^l ":"I "};for(const[i,r]of Object.entries(o)){const l=new RegExp(i,"gi");n=n.replace(l,r)}return{...t,text:n}})}}const se=new He;Q.GlobalWorkerOptions.workerSrc="/client-ocr-app/pdf.worker.min.js";ce.wasm.wasmPaths="/client-ocr-app/assets/";ce.wasm.numThreads=1;const ve="/client-ocr-app/models/",k={det_limit_side_len:1280,det_db_thresh:.05,det_db_box_thresh:.15,det_db_unclip_ratio:2.5,drop_score:.05,mean:[.485,.456,.406],std:[.229,.224,.225]};class We{constructor(){this.detectionSession=null,this.recognitionSession=null,this.charDict=[],this.initialized=!1,this.canvas=null,this.ctx=null,this.modelConfig={detection:"PP-OCRv5_mobile_det_infer.onnx",recognition:"en_PP-OCRv4_mobile_rec_infer.onnx",dictionary:"en_dict.txt"}}setModelConfig(e){e.detection&&(this.modelConfig.detection=e.detection),e.recognition&&(this.modelConfig.recognition=e.recognition),e.dictionary&&(this.modelConfig.dictionary=e.dictionary),this.initialized=!1}async initialize(e){this.initialized=!1;try{this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),e==null||e({status:"loading",message:"Loading dictionary...",progress:10}),await this.loadDictionary();const t=this.modelConfig.detection.replace(".onnx","").replace(/_/g," ");e==null||e({status:"loading",message:`Loading ${t}...`,progress:30}),this.detectionSession&&await this.detectionSession.release(),this.detectionSession=await me.create(ve+this.modelConfig.detection,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),console.log("Detection model loaded:",this.detectionSession.inputNames,this.detectionSession.outputNames);const n=this.modelConfig.recognition.replace(".onnx","").replace(/_/g," ");e==null||e({status:"loading",message:`Loading ${n}...`,progress:70}),this.recognitionSession&&await this.recognitionSession.release(),this.recognitionSession=await me.create(ve+this.modelConfig.recognition,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),console.log("Recognition model loaded:",this.recognitionSession.inputNames,this.recognitionSession.outputNames),this.initialized=!0,e==null||e({status:"ready",message:"PP-OCR models loaded successfully!",progress:100})}catch(t){throw console.error("Failed to initialize PP-OCR models:",t),t}}async loadDictionary(){try{const t=await(await fetch(ve+this.modelConfig.dictionary)).text();this.charDict=t.split(`
`).filter(n=>n.trim()),this.charDict.unshift(" "),console.log(`Loaded dictionary ${this.modelConfig.dictionary} with ${this.charDict.length} characters`)}catch(e){console.error("Failed to load dictionary:",e),this.charDict=[" "];for(let t=32;t<127;t++)this.charDict.push(String.fromCharCode(t))}}async process(e){if(!this.initialized)throw new Error("OCR engine not initialized");if(e.type==="application/pdf")return await this.processPDF(e);const t=await this.blobToImage(e),n=await this.detectText(t);return await this.recognizeText(t,n)}async detectText(e){if(!this.detectionSession)throw new Error("Detection model not loaded");const{resizedImage:t,ratio:n}=await this.resizeForDetection(e),o=await this.preprocessForDetection(t),i={[this.detectionSession.inputNames[0]]:o},l=(await this.detectionSession.run(i))[this.detectionSession.outputNames[0]];return await this.postprocessDetection(l,t.width,t.height,n)}async resizeForDetection(e){const t=k.det_limit_side_len;let n=e.width,o=e.height,i=1;Math.max(o,n)>t&&(i=t/Math.max(o,n));const r=Math.ceil(n*i),l=Math.ceil(o*i),s=Math.ceil(r/32)*32,d=Math.ceil(l/32)*32;this.canvas.width=s,this.canvas.height=d,this.ctx.fillStyle="white",this.ctx.fillRect(0,0,s,d),this.ctx.drawImage(e,0,0,r,l);const h=new Image;return new Promise(c=>{this.canvas.toBlob(u=>{const g=URL.createObjectURL(u);h.onload=()=>{URL.revokeObjectURL(g),c({resizedImage:h,ratio:i})},h.src=g})})}async preprocessForDetection(e){this.canvas.width=e.width,this.canvas.height=e.height,this.ctx.drawImage(e,0,0);const n=this.ctx.getImageData(0,0,e.width,e.height).data,o=e.width*e.height,i=new Float32Array(3*o);for(let r=0;r<o;r++){const l=r*4;i[r]=(n[l]/255-k.mean[0])/k.std[0],i[o+r]=(n[l+1]/255-k.mean[1])/k.std[1],i[2*o+r]=(n[l+2]/255-k.mean[2])/k.std[2]}return new fe("float32",i,[1,3,e.height,e.width])}async postprocessDetection(e,t,n,o){const[i,r,l,s]=e.dims,d=e.data,h=new Float32Array(l*s);for(let v=0;v<l*s;v++)h[v]=1/(1+Math.exp(-d[v]));const c=new Uint8Array(l*s),u=k.det_db_thresh;for(let v=0;v<l*s;v++)c[v]=h[v]>u?1:0;const g=[],y=new Set;for(let v=0;v<l;v++)for(let L=0;L<s;L++){const R=v*s+L;if(c[R]===1&&!y.has(R)&&h[R]>k.det_db_box_thresh){const b=this.expandBox(c,h,L,v,s,l,y);if(b){const O={points:b.points.map(I=>[Math.round(I[0]*t/s/o),Math.round(I[1]*n/l/o)]),score:b.score};g.push(O)}}}return this.sortBoxes(g)}expandBox(e,t,n,o,i,r,l){let s=n,d=n,h=o,c=o,u=0,g=0;const y=[[n,o]];for(l.add(o*i+n);y.length>0;){const[R,b]=y.shift();u+=t[b*i+R],g++;for(let O=-1;O<=1;O++)for(let I=-1;I<=1;I++){const M=R+I,B=b+O,C=B*i+M;M>=0&&M<i&&B>=0&&B<r&&e[C]===1&&!l.has(C)&&(l.add(C),y.push([M,B]),s=Math.min(s,M),d=Math.max(d,M),h=Math.min(h,B),c=Math.max(c,B))}}if(d-s<3||c-h<3)return null;const v=k.det_db_unclip_ratio,L=Math.max(d-s,c-h)*(v-1)/2;return s=Math.max(0,s-L),d=Math.min(i-1,d+L),h=Math.max(0,h-L),c=Math.min(r-1,c+L),{points:[[s,h],[d,h],[d,c],[s,c]],score:u/g}}sortBoxes(e){return e.sort((t,n)=>{const o=Math.min(...t.points.map(r=>r[1])),i=Math.min(...n.points.map(r=>r[1]));if(Math.abs(o-i)<10){const r=Math.min(...t.points.map(s=>s[0])),l=Math.min(...n.points.map(s=>s[0]));return r-l}return o-i})}async recognizeText(e,t){if(!this.recognitionSession)throw new Error("Recognition model not loaded");const n=[];for(const o of t){const i=await this.cropToBox(e,o),r=await this.preprocessForRecognition(i),l={[this.recognitionSession.inputNames[0]]:r},s=await this.recognitionSession.run(l),d=await this.decodeRecognition(s[this.recognitionSession.outputNames[0]]);d.score>=k.drop_score&&n.push({text:d.text,confidence:d.score,box:o.points})}return n}async cropToBox(e,t){const n=t.points,o=Math.min(...n.map(c=>c[0])),i=Math.max(...n.map(c=>c[0])),r=Math.min(...n.map(c=>c[1])),l=Math.max(...n.map(c=>c[1])),s=i-o,d=l-r;this.canvas.width=s,this.canvas.height=d,this.ctx.drawImage(e,o,r,s,d,0,0,s,d);const h=new Image;return new Promise(c=>{this.canvas.toBlob(u=>{const g=URL.createObjectURL(u);h.onload=()=>{URL.revokeObjectURL(g),c(h)},h.src=g})})}async preprocessForRecognition(e){const n=e.width/e.height;let o=Math.round(48*n);o=Math.max(o,48),this.canvas.width=o,this.canvas.height=48,this.ctx.fillStyle="white",this.ctx.fillRect(0,0,o,48),this.ctx.drawImage(e,0,0,o,48);const r=this.ctx.getImageData(0,0,o,48).data,l=o*48,s=new Float32Array(3*l);for(let d=0;d<l;d++){const h=d*4;s[d]=(r[h]/255-.5)/.5,s[l+d]=(r[h+1]/255-.5)/.5,s[2*l+d]=(r[h+2]/255-.5)/.5}return new fe("float32",s,[1,3,48,o])}async decodeRecognition(e){const[t,n,o]=e.dims,i=e.data,r=[],l=[];for(let c=0;c<n;c++){let u=0,g=i[c*o];for(let y=1;y<o;y++){const v=i[c*o+y];v>g&&(g=v,u=y)}r.push(u),l.push(g)}const s=[],d=[];let h=-1;for(let c=0;c<r.length;c++){const u=r[c];u!==0&&u!==h&&u<this.charDict.length&&(s.push(this.charDict[u]),d.push(l[c])),h=u}return{text:s.join(""),score:d.length>0?d.reduce((c,u)=>c+u)/d.length:0}}async processPDF(e){const t=await e.arrayBuffer(),n=await Q.getDocument({data:t}).promise,o=n.numPages,i=[];for(let r=1;r<=o;r++){const l=await n.getPage(r),s=l.getViewport({scale:2}),d=document.createElement("canvas"),h=d.getContext("2d");d.width=s.width,d.height=s.height,await l.render({canvasContext:h,viewport:s}).promise;const c=await new Promise(v=>d.toBlob(v,"image/png")),u=await this.blobToImage(c),g=await this.detectText(u),y=await this.recognizeText(u,g);i.push({page:r,results:y})}return i}async blobToImage(e){return new Promise((t,n)=>{const o=new Image;o.onload=()=>t(o),o.onerror=n,o.src=URL.createObjectURL(e)})}}const Z=new We;var Ge={exports:{}};(function(a){var e=function(t){var n=Object.prototype,o=n.hasOwnProperty,i=Object.defineProperty||function(f,p,w){f[p]=w.value},r,l=typeof Symbol=="function"?Symbol:{},s=l.iterator||"@@iterator",d=l.asyncIterator||"@@asyncIterator",h=l.toStringTag||"@@toStringTag";function c(f,p,w){return Object.defineProperty(f,p,{value:w,enumerable:!0,configurable:!0,writable:!0}),f[p]}try{c({},"")}catch{c=function(p,w,E){return p[w]=E}}function u(f,p,w,E){var m=p&&p.prototype instanceof O?p:O,x=Object.create(m.prototype),S=new he(E||[]);return i(x,"_invoke",{value:G(f,w,S)}),x}t.wrap=u;function g(f,p,w){try{return{type:"normal",arg:f.call(p,w)}}catch(E){return{type:"throw",arg:E}}}var y="suspendedStart",v="suspendedYield",L="executing",R="completed",b={};function O(){}function I(){}function M(){}var B={};c(B,s,function(){return this});var C=Object.getPrototypeOf,D=C&&C(C(ue([])));D&&D!==n&&o.call(D,s)&&(B=D);var j=M.prototype=O.prototype=Object.create(B);I.prototype=M,i(j,"constructor",{value:M,configurable:!0}),i(M,"constructor",{value:I,configurable:!0}),I.displayName=c(M,h,"GeneratorFunction");function re(f){["next","throw","return"].forEach(function(p){c(f,p,function(w){return this._invoke(p,w)})})}t.isGeneratorFunction=function(f){var p=typeof f=="function"&&f.constructor;return p?p===I||(p.displayName||p.name)==="GeneratorFunction":!1},t.mark=function(f){return Object.setPrototypeOf?Object.setPrototypeOf(f,M):(f.__proto__=M,c(f,h,"GeneratorFunction")),f.prototype=Object.create(j),f},t.awrap=function(f){return{__await:f}};function U(f,p){function w(x,S,_,$){var P=g(f[x],f,S);if(P.type==="throw")$(P.arg);else{var J=P.arg,V=J.value;return V&&typeof V=="object"&&o.call(V,"__await")?p.resolve(V.__await).then(function(K){w("next",K,_,$)},function(K){w("throw",K,_,$)}):p.resolve(V).then(function(K){J.value=K,_(J)},function(K){return w("throw",K,_,$)})}}var E;function m(x,S){function _(){return new p(function($,P){w(x,S,$,P)})}return E=E?E.then(_,_):_()}i(this,"_invoke",{value:m})}re(U.prototype),c(U.prototype,d,function(){return this}),t.AsyncIterator=U,t.async=function(f,p,w,E,m){m===void 0&&(m=Promise);var x=new U(u(f,p,w,E),m);return t.isGeneratorFunction(p)?x:x.next().then(function(S){return S.done?S.value:x.next()})};function G(f,p,w){var E=y;return function(x,S){if(E===L)throw new Error("Generator is already running");if(E===R){if(x==="throw")throw S;return ge()}for(w.method=x,w.arg=S;;){var _=w.delegate;if(_){var $=q(_,w);if($){if($===b)continue;return $}}if(w.method==="next")w.sent=w._sent=w.arg;else if(w.method==="throw"){if(E===y)throw E=R,w.arg;w.dispatchException(w.arg)}else w.method==="return"&&w.abrupt("return",w.arg);E=L;var P=g(f,p,w);if(P.type==="normal"){if(E=w.done?R:v,P.arg===b)continue;return{value:P.arg,done:w.done}}else P.type==="throw"&&(E=R,w.method="throw",w.arg=P.arg)}}}function q(f,p){var w=p.method,E=f.iterator[w];if(E===r)return p.delegate=null,w==="throw"&&f.iterator.return&&(p.method="return",p.arg=r,q(f,p),p.method==="throw")||w!=="return"&&(p.method="throw",p.arg=new TypeError("The iterator does not provide a '"+w+"' method")),b;var m=g(E,f.iterator,p.arg);if(m.type==="throw")return p.method="throw",p.arg=m.arg,p.delegate=null,b;var x=m.arg;if(!x)return p.method="throw",p.arg=new TypeError("iterator result is not an object"),p.delegate=null,b;if(x.done)p[f.resultName]=x.value,p.next=f.nextLoc,p.method!=="return"&&(p.method="next",p.arg=r);else return x;return p.delegate=null,b}re(j),c(j,h,"Generator"),c(j,s,function(){return this}),c(j,"toString",function(){return"[object Generator]"});function le(f){var p={tryLoc:f[0]};1 in f&&(p.catchLoc=f[1]),2 in f&&(p.finallyLoc=f[2],p.afterLoc=f[3]),this.tryEntries.push(p)}function X(f){var p=f.completion||{};p.type="normal",delete p.arg,f.completion=p}function he(f){this.tryEntries=[{tryLoc:"root"}],f.forEach(le,this),this.reset(!0)}t.keys=function(f){var p=Object(f),w=[];for(var E in p)w.push(E);return w.reverse(),function m(){for(;w.length;){var x=w.pop();if(x in p)return m.value=x,m.done=!1,m}return m.done=!0,m}};function ue(f){if(f){var p=f[s];if(p)return p.call(f);if(typeof f.next=="function")return f;if(!isNaN(f.length)){var w=-1,E=function m(){for(;++w<f.length;)if(o.call(f,w))return m.value=f[w],m.done=!1,m;return m.value=r,m.done=!0,m};return E.next=E}}return{next:ge}}t.values=ue;function ge(){return{value:r,done:!0}}return he.prototype={constructor:he,reset:function(f){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(X),!f)for(var p in this)p.charAt(0)==="t"&&o.call(this,p)&&!isNaN(+p.slice(1))&&(this[p]=r)},stop:function(){this.done=!0;var f=this.tryEntries[0],p=f.completion;if(p.type==="throw")throw p.arg;return this.rval},dispatchException:function(f){if(this.done)throw f;var p=this;function w($,P){return x.type="throw",x.arg=f,p.next=$,P&&(p.method="next",p.arg=r),!!P}for(var E=this.tryEntries.length-1;E>=0;--E){var m=this.tryEntries[E],x=m.completion;if(m.tryLoc==="root")return w("end");if(m.tryLoc<=this.prev){var S=o.call(m,"catchLoc"),_=o.call(m,"finallyLoc");if(S&&_){if(this.prev<m.catchLoc)return w(m.catchLoc,!0);if(this.prev<m.finallyLoc)return w(m.finallyLoc)}else if(S){if(this.prev<m.catchLoc)return w(m.catchLoc,!0)}else if(_){if(this.prev<m.finallyLoc)return w(m.finallyLoc)}else throw new Error("try statement without catch or finally")}}},abrupt:function(f,p){for(var w=this.tryEntries.length-1;w>=0;--w){var E=this.tryEntries[w];if(E.tryLoc<=this.prev&&o.call(E,"finallyLoc")&&this.prev<E.finallyLoc){var m=E;break}}m&&(f==="break"||f==="continue")&&m.tryLoc<=p&&p<=m.finallyLoc&&(m=null);var x=m?m.completion:{};return x.type=f,x.arg=p,m?(this.method="next",this.next=m.finallyLoc,b):this.complete(x)},complete:function(f,p){if(f.type==="throw")throw f.arg;return f.type==="break"||f.type==="continue"?this.next=f.arg:f.type==="return"?(this.rval=this.arg=f.arg,this.method="return",this.next="end"):f.type==="normal"&&p&&(this.next=p),b},finish:function(f){for(var p=this.tryEntries.length-1;p>=0;--p){var w=this.tryEntries[p];if(w.finallyLoc===f)return this.complete(w.completion,w.afterLoc),X(w),b}},catch:function(f){for(var p=this.tryEntries.length-1;p>=0;--p){var w=this.tryEntries[p];if(w.tryLoc===f){var E=w.completion;if(E.type==="throw"){var m=E.arg;X(w)}return m}}throw new Error("illegal catch attempt")},delegateYield:function(f,p,w){return this.delegate={iterator:ue(f),resultName:p,nextLoc:w},this.method==="next"&&(this.arg=r),b}},t}(a.exports);try{regeneratorRuntime=e}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}})(Ge);var Se=(a,e)=>`${a}-${e}-${Math.random().toString(16).slice(3,8)}`;const qe=Se;let $e=0;var Fe=({id:a,action:e,payload:t={}})=>{let n=a;return typeof n>"u"&&(n=qe("Job",$e),$e+=1),{id:n,action:e,payload:t}},de={};let _e=!1;de.logging=_e;de.setLogging=a=>{_e=a};de.log=(...a)=>_e?console.log.apply(void 0,a):null;const Xe=Fe,{log:pe}=de,Ve=Se;let Ie=0;var Ke=()=>{const a=Ve("Scheduler",Ie),e={},t={};let n=[];Ie+=1;const o=()=>n.length,i=()=>Object.keys(e).length,r=()=>{if(n.length!==0){const c=Object.keys(e);for(let u=0;u<c.length;u+=1)if(typeof t[c[u]]>"u"){n[0](e[c[u]]);break}}},l=(c,u)=>new Promise((g,y)=>{const v=Xe({action:c,payload:u});n.push(async L=>{n.shift(),t[L.id]=v;try{g(await L[c].apply(void 0,[...u,v.id]))}catch(R){y(R)}finally{delete t[L.id],r()}}),pe(`[${a}]: Add ${v.id} to JobQueue`),pe(`[${a}]: JobQueue length=${n.length}`),r()});return{addWorker:c=>(e[c.id]=c,pe(`[${a}]: Add ${c.id}`),pe(`[${a}]: Number of workers=${i()}`),r(),c.id),addJob:async(c,...u)=>{if(i()===0)throw Error(`[${a}]: You need to have at least one worker before adding jobs`);return l(c,u)},terminate:async()=>{Object.keys(e).forEach(async c=>{await e[c].terminate()}),n=[]},getQueueLen:o,getNumWorkers:i}};function Je(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}var Ze=Je;const Qe=Ze;var et=a=>{const e={};return typeof WorkerGlobalScope<"u"?e.type="webworker":Qe()?e.type="electron":typeof document=="object"?e.type="browser":typeof process=="object"&&typeof ke=="function"&&(e.type="node"),typeof a>"u"?e:e[a]};const tt=et("type")==="browser",nt=tt?a=>new URL(a,window.location.href).href:a=>a;var ot=a=>{const e={...a};return["corePath","workerPath","langPath"].forEach(t=>{a[t]&&(e[t]=nt(e[t]))}),e},it=a=>{const e=[],t=[],n=[],o=[],i=[];return a.blocks&&a.blocks.forEach(r=>{r.paragraphs.forEach(l=>{l.lines.forEach(s=>{s.words.forEach(d=>{d.symbols.forEach(h=>{i.push({...h,page:a,block:r,paragraph:l,line:s,word:d})}),o.push({...d,page:a,block:r,paragraph:l,line:s})}),n.push({...s,page:a,block:r,paragraph:l})}),t.push({...l,page:a,block:r})}),e.push({...r,page:a})}),{...a,blocks:e,paragraphs:t,lines:n,words:o,symbols:i}},ze={TESSERACT_ONLY:0,LSTM_ONLY:1,TESSERACT_LSTM_COMBINED:2,DEFAULT:3};const st="5.1.1",rt={version:st};var at={workerBlobURL:!0,logger:()=>{}};const ct=rt.version,dt=at;var lt={...dt,workerPath:`https://cdn.jsdelivr.net/npm/tesseract.js@v${ct}/dist/worker.min.js`},ht=({workerPath:a,workerBlobURL:e})=>{let t;if(Blob&&URL&&e){const n=new Blob([`importScripts("${a}");`],{type:"application/javascript"});t=new Worker(URL.createObjectURL(n))}else t=new Worker(a);return t},ut=a=>{a.terminate()},gt=(a,e)=>{a.onmessage=({data:t})=>{e(t)}},pt=async(a,e)=>{a.postMessage(e)};const xe=a=>new Promise((e,t)=>{const n=new FileReader;n.onload=()=>{e(n.result)},n.onerror=({target:{error:{code:o}}})=>{t(Error(`File could not be read! Code=${o}`))},n.readAsArrayBuffer(a)}),Me=async a=>{let e=a;if(typeof a>"u")return"undefined";if(typeof a=="string")/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(a)?e=atob(a.split(",")[1]).split("").map(t=>t.charCodeAt(0)):e=await(await fetch(a)).arrayBuffer();else if(typeof HTMLElement<"u"&&a instanceof HTMLElement)a.tagName==="IMG"&&(e=await Me(a.src)),a.tagName==="VIDEO"&&(e=await Me(a.poster)),a.tagName==="CANVAS"&&await new Promise(t=>{a.toBlob(async n=>{e=await xe(n),t()})});else if(typeof OffscreenCanvas<"u"&&a instanceof OffscreenCanvas){const t=await a.convertToBlob();e=await xe(t)}else(a instanceof File||a instanceof Blob)&&(e=await xe(a));return new Uint8Array(e)};var mt=Me;const ft=lt,wt=ht,yt=ut,vt=gt,xt=pt,bt=mt;var Et={defaultOptions:ft,spawnWorker:wt,terminateWorker:yt,onMessage:vt,send:xt,loadImage:bt};const Lt=ot,Mt=it,Y=Fe,{log:Oe}=de,Rt=Se,ee=ze,{defaultOptions:St,spawnWorker:_t,terminateWorker:$t,onMessage:It,loadImage:Pe,send:Ot}=Et;let Te=0;var Be=async(a="eng",e=ee.LSTM_ONLY,t={},n={})=>{const o=Rt("Worker",Te),{logger:i,errorHandler:r,...l}=Lt({...St,...t}),s={},d={},h=typeof a=="string"?a.split("+"):a;let c=e,u=n;const g=[ee.DEFAULT,ee.LSTM_ONLY].includes(e)&&!l.legacyCore;let y,v;const L=new Promise((m,x)=>{v=m,y=x}),R=m=>{y(m.message)};let b=_t(l);b.onerror=R,Te+=1;const O=(m,x)=>{s[m]=x},I=(m,x)=>{d[m]=x},M=({id:m,action:x,payload:S})=>new Promise((_,$)=>{Oe(`[${o}]: Start ${m}, action=${x}`);const P=`${x}-${m}`;O(P,_),I(P,$),Ot(b,{workerId:o,jobId:m,action:x,payload:S})}),B=()=>console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"),C=m=>M(Y({id:m,action:"load",payload:{options:{lstmOnly:g,corePath:l.corePath,logging:l.logging}}})),D=(m,x,S)=>M(Y({id:S,action:"FS",payload:{method:"writeFile",args:[m,x]}})),j=(m,x)=>M(Y({id:x,action:"FS",payload:{method:"readFile",args:[m,{encoding:"utf8"}]}})),re=(m,x)=>M(Y({id:x,action:"FS",payload:{method:"unlink",args:[m]}})),U=(m,x,S)=>M(Y({id:S,action:"FS",payload:{method:m,args:x}})),G=()=>console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)"),q=(m,x)=>M(Y({id:x,action:"loadLanguage",payload:{langs:m,options:{langPath:l.langPath,dataPath:l.dataPath,cachePath:l.cachePath,cacheMethod:l.cacheMethod,gzip:l.gzip,lstmOnly:[ee.DEFAULT,ee.LSTM_ONLY].includes(c)&&!l.legacyLang}}})),le=()=>console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)"),X=(m,x,S,_)=>M(Y({id:_,action:"initialize",payload:{langs:m,oem:x,config:S}})),he=(m="eng",x,S,_)=>{if(g&&[ee.TESSERACT_ONLY,ee.TESSERACT_LSTM_COMBINED].includes(x))throw Error("Legacy model requested but code missing.");const $=x||c;c=$;const P=S||u;u=P;const V=(typeof m=="string"?m.split("+"):m).filter(K=>!h.includes(K));return h.push(...V),V.length>0?q(V,_).then(()=>X(m,$,P,_)):X(m,$,P,_)},ue=(m={},x)=>M(Y({id:x,action:"setParameters",payload:{params:m}})),ge=async(m,x={},S={blocks:!0,text:!0,hocr:!0,tsv:!0},_)=>M(Y({id:_,action:"recognize",payload:{image:await Pe(m),options:x,output:S}})),f=(m="Tesseract OCR Result",x=!1,S)=>(console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."),M(Y({id:S,action:"getPDF",payload:{title:m,textonly:x}}))),p=async(m,x)=>{if(g)throw Error("`worker.detect` requires Legacy model, which was not loaded.");return M(Y({id:x,action:"detect",payload:{image:await Pe(m)}}))},w=async()=>(b!==null&&($t(b),b=null),Promise.resolve());It(b,({workerId:m,jobId:x,status:S,action:_,data:$})=>{const P=`${_}-${x}`;if(S==="resolve"){Oe(`[${m}]: Complete ${x}`);let J=$;_==="recognize"?J=Mt($):_==="getPDF"&&(J=Array.from({...$,length:Object.keys($).length})),s[P]({jobId:x,data:J})}else if(S==="reject")if(d[P]($),_==="load"&&y($),r)r($);else throw Error($);else S==="progress"&&i({...$,userJobId:x})});const E={id:o,worker:b,setResolve:O,setReject:I,load:B,writeText:D,readText:j,removeFile:re,FS:U,loadLanguage:G,initialize:le,reinitialize:he,setParameters:ue,recognize:ge,getPDF:f,detect:p,terminate:w};return C().then(()=>q(a)).then(()=>X(a,e,n)).then(()=>v(E)).catch(()=>{}),L};const Ne=Be,Pt=async(a,e,t)=>{const n=await Ne(e,1,t);return n.recognize(a).finally(async()=>{await n.terminate()})},Tt=async(a,e)=>{const t=await Ne("osd",0,e);return t.detect(a).finally(async()=>{await t.terminate()})};var Ct={recognize:Pt,detect:Tt},Ft={AFR:"afr",AMH:"amh",ARA:"ara",ASM:"asm",AZE:"aze",AZE_CYRL:"aze_cyrl",BEL:"bel",BEN:"ben",BOD:"bod",BOS:"bos",BUL:"bul",CAT:"cat",CEB:"ceb",CES:"ces",CHI_SIM:"chi_sim",CHI_TRA:"chi_tra",CHR:"chr",CYM:"cym",DAN:"dan",DEU:"deu",DZO:"dzo",ELL:"ell",ENG:"eng",ENM:"enm",EPO:"epo",EST:"est",EUS:"eus",FAS:"fas",FIN:"fin",FRA:"fra",FRK:"frk",FRM:"frm",GLE:"gle",GLG:"glg",GRC:"grc",GUJ:"guj",HAT:"hat",HEB:"heb",HIN:"hin",HRV:"hrv",HUN:"hun",IKU:"iku",IND:"ind",ISL:"isl",ITA:"ita",ITA_OLD:"ita_old",JAV:"jav",JPN:"jpn",KAN:"kan",KAT:"kat",KAT_OLD:"kat_old",KAZ:"kaz",KHM:"khm",KIR:"kir",KOR:"kor",KUR:"kur",LAO:"lao",LAT:"lat",LAV:"lav",LIT:"lit",MAL:"mal",MAR:"mar",MKD:"mkd",MLT:"mlt",MSA:"msa",MYA:"mya",NEP:"nep",NLD:"nld",NOR:"nor",ORI:"ori",PAN:"pan",POL:"pol",POR:"por",PUS:"pus",RON:"ron",RUS:"rus",SAN:"san",SIN:"sin",SLK:"slk",SLV:"slv",SPA:"spa",SPA_OLD:"spa_old",SQI:"sqi",SRP:"srp",SRP_LATN:"srp_latn",SWA:"swa",SWE:"swe",SYR:"syr",TAM:"tam",TEL:"tel",TGK:"tgk",TGL:"tgl",THA:"tha",TIR:"tir",TUR:"tur",UIG:"uig",UKR:"ukr",URD:"urd",UZB:"uzb",UZB_CYRL:"uzb_cyrl",VIE:"vie",YID:"yid"},zt={OSD_ONLY:"0",AUTO_OSD:"1",AUTO_ONLY:"2",AUTO:"3",SINGLE_COLUMN:"4",SINGLE_BLOCK_VERT_TEXT:"5",SINGLE_BLOCK:"6",SINGLE_LINE:"7",SINGLE_WORD:"8",CIRCLE_WORD:"9",SINGLE_CHAR:"10",SPARSE_TEXT:"11",SPARSE_TEXT_OSD:"12",RAW_LINE:"13"};const Bt=Ke,Nt=Be,At=Ct,Dt=Ft,jt=ze,Ut=zt,{setLogging:kt}=de;var Yt={languages:Dt,OEM:jt,PSM:Ut,createScheduler:Bt,createWorker:Nt,setLogging:kt,...At};const be=Ye(Yt);Q.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";class Ht{constructor(){this.initialized=!1,this.worker=null}async initialize(e){if(!this.initialized)try{e==null||e({status:"loading",message:"Loading Tesseract OCR engine...",progress:10}),this.worker=await be.createWorker("eng",1,{logger:t=>{t.status==="loading tesseract core"?e==null||e({status:"loading",message:"Loading OCR core...",progress:30}):t.status==="loading language traineddata"?e==null||e({status:"loading",message:"Loading English language model...",progress:60}):t.status==="initialized tesseract"&&(e==null||e({status:"loading",message:"Initializing OCR engine...",progress:90}))},errorHandler:t=>{console.error("Tesseract error:",t)}}),await this.worker.setParameters({tessedit_ocr_engine_mode:be.OEM.LSTM_ONLY,preserve_interword_spaces:"1",tessedit_pageseg_mode:be.PSM.AUTO}),this.initialized=!0,e==null||e({status:"ready",message:"Tesseract OCR engine loaded successfully!",progress:100})}catch(t){throw console.error("Failed to initialize Tesseract:",t),t}}async process(e){if(!this.initialized)throw new Error("OCR engine not initialized");if(e.type==="application/pdf")return await this.processPDF(e);const t=await this.worker.recognize(e);return this.formatResults(t)}formatResults(e){const t=[];for(const o of e.data.words)o.confidence>30&&t.push({box:[[o.bbox.x0,o.bbox.y0],[o.bbox.x1,o.bbox.y0],[o.bbox.x1,o.bbox.y1],[o.bbox.x0,o.bbox.y1]],text:o.text,confidence:o.confidence/100});return this.groupWordsIntoLines(t)}groupWordsIntoLines(e){if(e.length===0)return[];e.sort((o,i)=>o.box[0][1]-i.box[0][1]);const t=[];let n={words:[e[0]],minY:e[0].box[0][1],maxY:e[0].box[2][1]};for(let o=1;o<e.length;o++){const i=e[o],r=i.box[0][1];r<=n.maxY&&r>=n.minY-5?(n.words.push(i),n.minY=Math.min(n.minY,r),n.maxY=Math.max(n.maxY,i.box[2][1])):(t.push(this.mergeLine(n)),n={words:[i],minY:r,maxY:i.box[2][1]})}return n.words.length>0&&t.push(this.mergeLine(n)),t}mergeLine(e){e.words.sort((s,d)=>s.box[0][0]-d.box[0][0]);const t=Math.min(...e.words.map(s=>s.box[0][0])),n=Math.max(...e.words.map(s=>s.box[1][0])),o=Math.min(...e.words.map(s=>s.box[0][1])),i=Math.max(...e.words.map(s=>s.box[2][1])),r=e.words.map(s=>s.text).join(" "),l=e.words.reduce((s,d)=>s+d.confidence,0)/e.words.length;return{box:[[t,o],[n,o],[n,i],[t,i]],text:r,confidence:l}}async processPDF(e){const t=await e.arrayBuffer(),n=await Q.getDocument({data:t}).promise,o=n.numPages,i=[];for(let r=1;r<=o;r++){const l=await n.getPage(r),s=l.getViewport({scale:2}),d=document.createElement("canvas"),h=d.getContext("2d");d.width=s.width,d.height=s.height,await l.render({canvasContext:h,viewport:s}).promise;const c=await new Promise(y=>d.toBlob(y,"image/png")),u=await this.worker.recognize(c),g=this.formatResults(u);i.push({page:r,results:g})}return i}async cleanup(){this.worker&&(await this.worker.terminate(),this.worker=null,this.initialized=!1)}}const te=new Ht;Q.GlobalWorkerOptions.workerSrc="/client-ocr-app/pdf.worker.min.js";let ie=null,T="tesseract",A="improved",N=te;Object.defineProperty(window,"currentEngine",{get:()=>T,set:a=>{console.warn("Attempted to set currentEngine directly. Use handleEngineChange instead.")}});const Re=document.getElementById("fileInput"),ne=document.getElementById("uploadArea"),Ae=document.getElementById("previewSection"),H=document.getElementById("previewImage"),Wt=document.getElementById("processBtn"),we=document.getElementById("resultsSection"),Ee=document.getElementById("loadingIndicator"),ae=document.getElementById("ocrResults"),Gt=document.getElementById("copyBtn"),qt=document.getElementById("downloadBtn"),Xt=document.getElementById("resetBtn");async function Vt(){var a,e;console.log("Initializing OCR engines..."),z("Loading OCR engines...","info");try{await Promise.all([se.initialize(n=>{T==="paddle"&&A==="improved"&&z(n.message,n.status==="ready"?"success":"info");const o=document.querySelector("#loadingIndicator p");o&&n.progress!==void 0&&T==="paddle"&&A==="improved"&&(o.textContent=`${n.message} (${n.progress}%)`)}),Z.initialize(n=>{T==="paddle"&&A==="standard"&&z(n.message,n.status==="ready"?"success":"info")}),te.initialize(n=>{T==="tesseract"&&z(n.message,n.status==="ready"?"success":"info")})]),console.log("OCR engines loaded successfully!"),z("Ready to process images","success"),Kt();const t=document.querySelector('input[name="ocrEngine"]:checked');t&&(T=t.value,T==="paddle"?(N=A==="improved"?se:Z,document.getElementById("paddleOptions").style.display="block"):(N=te,document.getElementById("paddleOptions").style.display="none"),console.log("Initial engine set to:",T),console.log("Initial OCR engine object:",N))}catch(t){if(console.error("Failed to initialize OCR engines:",t),(a=t.message)!=null&&a.includes("onnx")||(e=t.message)!=null&&e.includes("ONNX")?W("Failed to load PaddleOCR models. This may be due to browser compatibility issues. Please try using Tesseract.js instead."):W("Failed to load OCR engines. Please check your internet connection and refresh the page."),te.initialized){z("Tesseract.js is ready. PaddleOCR failed to load.","warning"),T="tesseract",N=te;const n=document.getElementById("engineTesseract");n&&(n.checked=!0)}}}function Kt(){ne.addEventListener("click",()=>Re.click()),Re.addEventListener("change",Qt),ne.addEventListener("dragover",en),ne.addEventListener("dragleave",tn),ne.addEventListener("drop",nn),Wt.addEventListener("click",on),Gt.addEventListener("click",rn),qt.addEventListener("click",an),Xt.addEventListener("click",cn),document.querySelectorAll('input[name="ocrEngine"]').forEach(e=>{console.log("Adding event listener to radio:",e.value,e),e.addEventListener("change",Jt)});const a=document.querySelector('input[name="ocrEngine"]:checked');console.log("Initial checked engine:",a==null?void 0:a.value),document.querySelectorAll('input[name="preprocessing"]').forEach(e=>{e.addEventListener("change",Zt)}),document.getElementById("detectionModel").addEventListener("change",Le),document.getElementById("recognitionModel").addEventListener("change",Le),document.getElementById("dictionary").addEventListener("change",Le)}async function Jt(a){const e=a.target.value;console.log("Engine change event - new value:",e),console.log("Engine change event - old currentEngine:",T),T=e,T==="paddle"?(N=A==="improved"?se:Z,console.log("Set currentOCREngine to PaddleOCR:",A),console.log("Verify currentOCREngine:",N)):(N=te,console.log("Set currentOCREngine to Tesseract"));const t=document.getElementById("paddleOptions");t.style.display=T==="paddle"?"block":"none",z(`Switched to ${T==="paddle"?"PaddleOCR":"Tesseract.js"}`,"info"),console.log("Final currentEngine:",T),console.log("Final currentOCREngine:",N)}async function Zt(a){if(A=a.target.value,T==="paddle"){if(N=A==="improved"?se:Z,A==="standard"){const e=document.getElementById("detectionModel").value,t=document.getElementById("recognitionModel").value,n=document.getElementById("dictionary").value;Z.setModelConfig({detection:e,recognition:t,dictionary:n}),z("Loading standard preprocessing models...","info");try{await Z.initialize(o=>{z(o.message,o.status==="ready"?"success":"info")}),z("Standard preprocessing ready!","success")}catch(o){console.error("Failed to initialize standard preprocessing:",o),W("Failed to load standard preprocessing models"),A="improved",N=se,document.getElementById("preprocessImproved").checked=!0}}z(`Switched to ${A==="improved"?"Improved (PPU)":"Standard"} preprocessing`,"info")}}async function Le(){if(T!=="paddle")return;const a=document.getElementById("detectionModel").value,e=document.getElementById("recognitionModel").value,t=document.getElementById("dictionary").value;A==="improved"?se.setModelConfig({detection:a,recognition:e,dictionary:t}):Z.setModelConfig({detection:a,recognition:e,dictionary:t}),z("Loading new models...","info");try{await N.initialize(n=>{z(n.message,n.status==="ready"?"success":"info")}),z("Models updated successfully!","success")}catch(n){console.error("Failed to load new models:",n),W("Failed to load new models. Please try again.")}}function Qt(a){const e=a.target.files[0];e&&(e.type.startsWith("image/")||e.type==="application/pdf")?De(e):W("Please select a valid image or PDF file")}function en(a){a.preventDefault(),ne.classList.add("dragover")}function tn(a){a.preventDefault(),ne.classList.remove("dragover")}function nn(a){a.preventDefault(),ne.classList.remove("dragover");const e=a.dataTransfer.files[0];e&&(e.type.startsWith("image/")||e.type==="application/pdf")?De(e):W("Please drop a valid image or PDF file")}async function De(a){if(ie){const e=H.src;e&&e.startsWith("blob:")&&URL.revokeObjectURL(e),ie=null}if(ae.innerHTML="",we.style.display="none",ie=a,Ae.style.display="block",we.style.display="none",a.type==="application/pdf"){H.style.display="none";const e=H.parentElement;e.innerHTML="";const t=document.createElement("div");t.className="pdf-preview",t.innerHTML=`
            <div class="pdf-header">
                <h3>${a.name}</h3>
                <p class="pdf-info">Loading PDF preview...</p>
            </div>
            <div class="pdf-pages" id="pdfPages"></div>
        `,e.appendChild(t);try{const n=await a.arrayBuffer(),o=await Q.getDocument({data:n}).promise,i=o.numPages,r=t.querySelector(".pdf-info");r.textContent=`${i} page${i>1?"s":""}`;const l=document.getElementById("pdfPages"),s=Math.min(i,3);for(let d=1;d<=s;d++){const h=await o.getPage(d),c=h.getViewport({scale:.5}),u=document.createElement("div");u.className="pdf-page-preview";const g=document.createElement("canvas"),y=g.getContext("2d");g.height=c.height,g.width=c.width;const v={canvasContext:y,viewport:c};await h.render(v).promise,u.innerHTML=`<p>Page ${d}</p>`,u.appendChild(g),l.appendChild(u)}i>3&&(l.innerHTML+=`<p class="more-pages">... and ${i-3} more pages</p>`)}catch(n){console.error("Error rendering PDF preview:",n),t.querySelector(".pdf-info").textContent="Error loading PDF preview"}}else{const e=document.querySelector(".pdf-placeholder");e&&e.remove(),H.style.display="block";const t=URL.createObjectURL(a);H.src=t,H.onload=()=>{z('Image loaded. Click "Extract Text" to process.',"success")},H.onerror=()=>{URL.revokeObjectURL(t),W("Failed to load image")}}}async function on(){if(!ie){W("Please upload an image first");return}we.style.display="block",Ee.style.display="flex",ae.innerHTML="";const a=document.querySelector("#loadingIndicator p");let e=T==="paddle"?"PaddleOCR":"Tesseract.js";T==="paddle"&&(e+=` (${A==="improved"?"Improved PPU":"Standard"})`),a&&(a.textContent=`Processing image with ${e}...`);try{console.log(`Processing image with ${e}...`),console.log("Current engine variable:",T),console.log("Current OCR engine object:",N),console.log("Current OCR engine name:",N.constructor.name),z("Detecting and recognizing text...","info");const t=performance.now();T==="paddle"&&N===te&&(console.error("Engine mismatch detected! Expected PaddleOCR but got Tesseract"),N=A==="improved"?se:Z,console.log("Forced engine to:",N));const n=await N.process(ie),o=performance.now()-t;console.log(`Processing completed in ${o.toFixed(2)}ms`),console.log("OCR Results:",n),Ee.style.display="none",n&&n.length>0?(Ce(n,o,e),z(`Text extraction complete! Found ${n.length} text regions.`,"success")):(Ce([],o,e),z("No text found in the image","warning"))}catch(t){if(console.error("OCR processing error:",t),console.error("Error code:",t.code),Ee.style.display="none",T==="paddle"&&(t.code===30757872||t.message.includes("30757872"))){if(W("PaddleOCR failed: ONNX Runtime error. The PP-OCRv5 model appears to be incompatible with your browser."),z("Consider using Tesseract.js for better compatibility","warning"),confirm("PaddleOCR failed due to browser compatibility. Would you like to switch to Tesseract.js?")){const o=document.getElementById("engineTesseract");o&&(o.checked=!0,o.dispatchEvent(new Event("change")))}}else W("Failed to process image: "+t.message)}}function Ce(a,e,t="PaddleOCR"){var i;const n=Array.isArray(a)&&((i=a[0])==null?void 0:i.page)!==void 0,o=T==="paddle"&&a.length>0&&a[0]&&a[0].box;if(console.log("Display check - currentEngine:",T,"isPaddleWithBoxes:",o,"results:",a),n){let r="",l=0,s="";a.forEach(d=>{const h=d.results.map(c=>c.text).join(`
`);r+=`
--- Page ${d.page} ---
${h}
`,l+=d.results.length,s+=`
                <div class="page-results">
                    <h4>Page ${d.page}</h4>
                    <ul class="detection-list">
                        ${d.results.map((c,u)=>`
                            <li data-index="${u}">
                                <span class="detection-index">${u+1}.</span>
                                <span class="detection-text">${oe(c.text)}</span>
                                <span class="detection-confidence">${(c.confidence*100).toFixed(1)}%</span>
                            </li>
                        `).join("")}
                    </ul>
                </div>
            `}),ae.innerHTML=`
            <div class="ocr-stats">
                <p><strong>Processing Time:</strong> ${(e/1e3).toFixed(2)}s</p>
                <p><strong>Pages Processed:</strong> ${a.length}</p>
                <p><strong>Total Text Regions:</strong> ${l}</p>
                <p><strong>Engine:</strong> ${t}</p>
            </div>
            <div class="text-result">
                <h3>Extracted Text:</h3>
                <div class="text-content" id="extractedText">${oe(r||"No text detected")}</div>
            </div>
            <div class="detection-results">
                <h3>Detection Details by Page:</h3>
                ${s}
            </div>
        `}else if(o)sn(a,e,t);else{const r=a.map(l=>l.text).join(`
`);ae.innerHTML=`
            <div class="ocr-stats">
                <p><strong>Processing Time:</strong> ${(e/1e3).toFixed(2)}s</p>
                <p><strong>Text Regions Found:</strong> ${a.length}</p>
                <p><strong>Engine:</strong> ${t}</p>
            </div>
            <div class="text-result">
                <h3>Extracted Text:</h3>
                <div class="text-content" id="extractedText">${oe(r||"No text detected")}</div>
            </div>
            <div class="detection-results">
                <h3>Detection Details:</h3>
                <ul class="detection-list">
                    ${a.map((l,s)=>`
                        <li>
                            <span class="detection-index">${s+1}.</span>
                            <span class="detection-text">${oe(l.text)}</span>
                            <span class="detection-confidence">${(l.confidence*100).toFixed(1)}%</span>
                        </li>
                    `).join("")}
                </ul>
            </div>
        `}}function sn(a,e,t){const n=a.map(i=>i.text).join(`
`),o=hn(a);ae.innerHTML=`
        <div class="ocr-stats">
            <p><strong>Processing Time:</strong> ${(e/1e3).toFixed(2)}s</p>
            <p><strong>Text Regions Found:</strong> ${a.length}</p>
            <p><strong>Engine:</strong> ${t}</p>
            <p><strong>Average Confidence:</strong> ${ln(a)}%</p>
        </div>
        
        <div class="paddle-results-container">
            <div class="result-tabs">
                <button class="result-tab active" onclick="showResultTab('visual')">Visual Results</button>
                <button class="result-tab" onclick="showResultTab('text')">Text Only</button>
                <button class="result-tab" onclick="showResultTab('grouped')">Grouped by Line</button>
            </div>
            
            <div id="visualResults" class="tab-content active">
                <div class="result-image-container">
                    <img id="resultImage" src="${H.src}" alt="OCR Result">
                    <div class="bounding-box-overlay" id="boundingBoxOverlay"></div>
                </div>
                <div class="detection-results">
                    <h3>Detected Text Regions:</h3>
                    <ul class="detection-list" id="visualDetectionList">
                        ${a.map((i,r)=>{const l=je(i.confidence);return`
                                <li data-index="${r}" onmouseover="highlightBox(${r})" onmouseout="unhighlightBox(${r})" onclick="selectBox(${r})">
                                    <span class="detection-index">${r+1}.</span>
                                    <span class="detection-text">${oe(i.text)}</span>
                                    <span class="detection-confidence ${l}">${(i.confidence*100).toFixed(1)}%</span>
                                </li>
                            `}).join("")}
                    </ul>
                </div>
            </div>
            
            <div id="textResults" class="tab-content grouped-results">
                <div class="text-result">
                    <h3>Extracted Text:</h3>
                    <div class="text-content" id="extractedText">${oe(n||"No text detected")}</div>
                </div>
            </div>
            
            <div id="groupedResults" class="tab-content grouped-results">
                <h3>Text Grouped by Line:</h3>
                ${o.map((i,r)=>`
                    <div class="text-region-group">
                        <div class="region-header">
                            <span class="region-title">Line ${r+1}</span>
                            <div class="region-confidence">
                                <div class="confidence-bar">
                                    <div class="confidence-fill" style="width: ${i.avgConfidence}%"></div>
                                </div>
                                <span class="confidence-text">${i.avgConfidence.toFixed(1)}%</span>
                            </div>
                        </div>
                        <p>${oe(i.text)}</p>
                    </div>
                `).join("")}
            </div>
        </div>
    `,setTimeout(()=>Ue(a),100)}async function rn(){const a=document.getElementById("extractedText");if(a)try{await navigator.clipboard.writeText(a.textContent),dn("Text copied to clipboard!")}catch{W("Failed to copy text")}}function an(){const a=document.getElementById("extractedText");if(a){const e=a.textContent,t=new Blob([e],{type:"text/plain"}),n=URL.createObjectURL(t),o=document.createElement("a");o.href=n,o.download=`pp-ocrv5-result-${Date.now()}.txt`,o.click(),URL.revokeObjectURL(n)}}function cn(){if(ie){const e=H.src;e&&e.startsWith("blob:")&&URL.revokeObjectURL(e),ie=null}Re.value="",Ae.style.display="none",we.style.display="none",ae.innerHTML="",H.src="";const a=H.parentElement;a.innerHTML='<img id="previewImage" alt="Preview">',window.previewImage=document.getElementById("previewImage"),z("Ready to process a new image","info")}function oe(a){const e=document.createElement("div");return e.textContent=a,e.innerHTML}function W(a){z(a,"error");const e=document.createElement("div");e.className="toast error",e.textContent=a,document.body.appendChild(e),setTimeout(()=>{e.remove()},5e3)}function dn(a){const e=document.createElement("div");e.className="toast success",e.textContent=a,document.body.appendChild(e),setTimeout(()=>{e.remove()},3e3)}function z(a,e="info"){console.log(`[${e.toUpperCase()}] ${a}`);const t=document.getElementById("status");t&&(t.textContent=a,t.className=`status ${e}`)}function ln(a){return a.length===0?0:(a.reduce((t,n)=>t+n.confidence,0)/a.length*100).toFixed(1)}function je(a){const e=a*100;return e>=80?"high-confidence":e>=60?"medium-confidence":"low-confidence"}function hn(a){if(a.length===0)return[];const e=[...a].sort((o,i)=>{const r=Math.min(...o.box.map(s=>s[1])),l=Math.min(...i.box.map(s=>s[1]));return r-l}),t=[];let n=[e[0]];for(let o=1;o<e.length;o++){const i=Math.min(...e[o-1].box.map(l=>l[1])),r=Math.min(...e[o].box.map(l=>l[1]));Math.abs(r-i)<20?n.push(e[o]):(t.push(n),n=[e[o]])}return n.length>0&&t.push(n),t.map(o=>{o.sort((l,s)=>{const d=Math.min(...l.box.map(c=>c[0])),h=Math.min(...s.box.map(c=>c[0]));return d-h});const i=o.map(l=>l.text).join(" "),r=o.reduce((l,s)=>l+s.confidence,0)/o.length*100;return{text:i,avgConfidence:r,items:o}})}function Ue(a){const e=document.getElementById("boundingBoxOverlay"),t=document.getElementById("resultImage");if(!e||!t)return;if(e.innerHTML="",!t.complete){t.onload=()=>Ue(a);return}const n=t.getBoundingClientRect(),o=t.naturalWidth/n.width,i=t.naturalHeight/n.height;a.forEach((r,l)=>{const s=r.box,d=Math.min(...s.map(v=>v[0]))/o,h=Math.min(...s.map(v=>v[1]))/i,c=Math.max(...s.map(v=>v[0]))/o,u=Math.max(...s.map(v=>v[1]))/i,g=document.createElement("div");g.className=`text-box ${je(r.confidence)}`,g.dataset.index=l,g.style.left=`${d}px`,g.style.top=`${h}px`,g.style.width=`${c-d}px`,g.style.height=`${u-h}px`;const y=document.createElement("div");y.className="text-box-label",y.textContent=`${l+1}: ${(r.confidence*100).toFixed(0)}%`,g.appendChild(y),g.onclick=()=>selectBox(l),e.appendChild(g)})}window.showResultTab=function(a){document.querySelectorAll(".result-tab").forEach(e=>{e.classList.remove("active")}),event.target.classList.add("active"),document.querySelectorAll(".tab-content").forEach(e=>{e.classList.remove("active")}),a==="visual"?document.getElementById("visualResults").classList.add("active"):a==="text"?document.getElementById("textResults").classList.add("active"):a==="grouped"&&document.getElementById("groupedResults").classList.add("active")};window.highlightBox=function(a){const e=document.querySelector(`.text-box[data-index="${a}"]`),t=document.querySelector(`#visualDetectionList li[data-index="${a}"]`);e&&e.classList.add("hover"),t&&t.classList.add("highlighted")};window.unhighlightBox=function(a){const e=document.querySelector(`.text-box[data-index="${a}"]`),t=document.querySelector(`#visualDetectionList li[data-index="${a}"]`);e&&e.classList.remove("hover"),t&&t.classList.remove("highlighted")};window.selectBox=function(a){document.querySelectorAll(".text-box.selected").forEach(t=>{t.classList.remove("selected")});const e=document.querySelector(`.text-box[data-index="${a}"]`);if(e){e.classList.add("selected");const t=document.querySelector(`#visualDetectionList li[data-index="${a}"]`);t&&(t.scrollIntoView({behavior:"smooth",block:"center"}),t.classList.add("highlighted"),setTimeout(()=>t.classList.remove("highlighted"),2e3))}};document.addEventListener("DOMContentLoaded",Vt);
//# sourceMappingURL=index-BLkYhQac.js.map
