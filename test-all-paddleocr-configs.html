<!DOCTYPE html>
<html>
<head>
    <title>PaddleOCR Configurations Performance Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1900px;
            margin: 0 auto;
            background: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .controls {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .test-category {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .test-category:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        .test-category.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        .test-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .test-card h3 {
            margin-top: 0;
            padding: 15px;
            margin: -20px -20px 20px -20px;
            color: white;
            text-align: center;
            font-size: 18px;
        }
        .tesseract h3 { background: #4CAF50; }
        .paddle-standard h3 { background: #FF9800; }
        .paddle-improved h3 { background: #2196F3; }
        .paddle-infographic h3 { background: #9C27B0; }
        .paddle-document h3 { background: #00BCD4; }
        .paddle-receipt h3 { background: #F44336; }
        .paddle-pdf h3 { background: #3F51B5; }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .metric {
            text-align: center;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        .metric-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }
        .metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        .performance-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .performance-good { background: #4CAF50; }
        .performance-average { background: #FF9800; }
        .performance-poor { background: #F44336; }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .results {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: pre-wrap;
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
        }
        .info { background: #d1ecf1; color: #0c5460; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        
        button {
            padding: 12px 24px;
            margin: 5px;
            cursor: pointer;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s;
        }
        button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #preview {
            max-width: 100%;
            max-height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px auto;
            display: block;
        }
        
        .performance-summary {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-top: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .performance-table th, .performance-table td {
            border: 1px solid #e0e0e0;
            padding: 12px;
            text-align: center;
        }
        .performance-table th {
            background: #f5f5f5;
            font-weight: bold;
        }
        .best-performer {
            background: #c8e6c9;
            font-weight: bold;
        }
        .outperforms-tesseract {
            background: #e8f5e9;
        }
        .underperforms {
            background: #ffebee;
        }
        
        .optimization-suggestions {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .suggestion-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        
        .winner-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background: gold;
            color: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .test-progress {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ PaddleOCR Performance Test Suite</h1>
        <p>Comprehensive testing of all PaddleOCR configurations against Tesseract baseline</p>
        <p>Goal: Ensure all PaddleOCR modes outperform Tesseract OCR</p>
    </div>
    
    <div class="controls">
        <h3>Select Test Category</h3>
        <div class="test-categories">
            <div class="test-category" data-type="general">üìÑ General Document</div>
            <div class="test-category" data-type="infographic">üé® Infographic</div>
            <div class="test-category" data-type="document">üìã Official Document</div>
            <div class="test-category" data-type="idcard">üÜî ID Card</div>
            <div class="test-category" data-type="receipt">üßæ Receipt</div>
            <div class="test-category" data-type="pdf">üìë PDF Document</div>
        </div>
        
        <h3>Upload Test Image</h3>
        <input type="file" id="fileInput" accept="image/*,application/pdf">
        
        <h3>Test Controls</h3>
        <button id="runAllTests" disabled>üî¨ Run All Configuration Tests</button>
        <button id="optimizeConfigs">‚ö° Auto-Optimize Underperforming Configs</button>
        <button id="exportResults">üìä Export Test Results</button>
        <button id="clearResults">üóëÔ∏è Clear All Results</button>
    </div>
    
    <div id="status" class="status info">Initializing OCR engines...</div>
    
    <div class="test-progress" id="testProgress" style="display: none;">
        <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
    </div>
    
    <img id="preview" style="display: none;" />
    
    <div id="testResults" style="display: none;">
        <div class="test-grid" id="testGrid"></div>
        
        <div class="performance-summary" id="performanceSummary" style="display: none;">
            <h3>üìä Performance Analysis</h3>
            <table class="performance-table" id="performanceTable">
                <thead>
                    <tr>
                        <th>Configuration</th>
                        <th>Processing Time (ms)</th>
                        <th>Text Detected (chars)</th>
                        <th>Word Count</th>
                        <th>Confidence (%)</th>
                        <th>Overall Score</th>
                        <th>vs Tesseract</th>
                    </tr>
                </thead>
                <tbody id="performanceBody"></tbody>
            </table>
            
            <div class="optimization-suggestions" id="optimizationSuggestions" style="display: none;">
                <h4>üîß Optimization Suggestions</h4>
                <div id="suggestionsList"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { ppOCRImprovedEngine } from './src/ppocr-improved-engine.js';
        import { ppOCREngine } from './src/ppocr-onnx-engine.js';
        import { tesseractOCREngine } from './src/tesseract-ocr-engine.js';
        import { INFOGRAPHIC_OCR_CONFIG, updatePaddleOCRConfig } from './src/infographic-ocr-config.js';
        import { 
            DOCUMENT_OCR_CONFIG, 
            RECEIPT_OCR_CONFIG,
            updatePaddleOCRForDocuments 
        } from './src/document-ocr-config.js';
        import { PDF_OCR_CONFIG, updatePaddleOCRForPDF } from './src/pdf-ocr-config.js';
        
        let currentImage = null;
        let currentCategory = null;
        let testResults = {};
        let isInitialized = false;
        
        // Test configurations
        const testConfigs = [
            { 
                name: 'Tesseract (Baseline)', 
                engine: 'tesseract', 
                class: 'tesseract',
                description: 'Industry standard OCR engine'
            },
            { 
                name: 'PaddleOCR Standard', 
                engine: 'paddle-standard', 
                class: 'paddle-standard',
                description: 'Default PaddleOCR configuration'
            },
            { 
                name: 'PaddleOCR Improved', 
                engine: 'paddle-improved', 
                class: 'paddle-improved',
                description: 'Enhanced preprocessing'
            },
            { 
                name: 'PaddleOCR Infographic', 
                engine: 'paddle-infographic', 
                class: 'paddle-infographic',
                description: 'Optimized for complex layouts'
            },
            { 
                name: 'PaddleOCR Document', 
                engine: 'paddle-document', 
                class: 'paddle-document',
                description: 'Optimized for official documents'
            },
            { 
                name: 'PaddleOCR Receipt', 
                engine: 'paddle-receipt', 
                class: 'paddle-receipt',
                description: 'Optimized for receipts'
            },
            { 
                name: 'PaddleOCR PDF', 
                engine: 'paddle-pdf', 
                class: 'paddle-pdf',
                description: 'Optimized for PDF documents'
            }
        ];
        
        // Initialize OCR engines
        async function initializeOCR() {
            setStatus('Initializing OCR engines...', 'info');
            try {
                await Promise.all([
                    ppOCRImprovedEngine.initialize((progress) => {
                        console.log('PaddleOCR Improved:', progress.message);
                    }),
                    ppOCREngine.initialize((progress) => {
                        console.log('PaddleOCR Standard:', progress.message);
                    }),
                    tesseractOCREngine.initialize((progress) => {
                        console.log('Tesseract:', progress.message);
                    })
                ]);
                isInitialized = true;
                setStatus('All OCR engines initialized! Select a test category and upload an image.', 'success');
                document.getElementById('runAllTests').disabled = false;
            } catch (error) {
                setStatus('Failed to initialize OCR engines: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        // Category selection
        document.querySelectorAll('.test-category').forEach(cat => {
            cat.addEventListener('click', (e) => {
                document.querySelectorAll('.test-category').forEach(c => c.classList.remove('active'));
                e.target.classList.add('active');
                currentCategory = e.target.dataset.type;
                setStatus(`Test category selected: ${e.target.textContent}`, 'info');
            });
        });
        
        // File handling
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                loadFile(file);
            }
        });
        
        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImage = e.target.result;
                document.getElementById('preview').src = currentImage;
                document.getElementById('preview').style.display = 'block';
                setStatus('Image loaded. Click "Run All Configuration Tests" to begin comprehensive testing.', 'success');
            };
            reader.readAsDataURL(file);
        }
        
        // Run all tests
        document.getElementById('runAllTests').addEventListener('click', async () => {
            if (!currentImage) {
                setStatus('Please upload an image first', 'error');
                return;
            }
            
            if (!currentCategory) {
                setStatus('Please select a test category first', 'error');
                return;
            }
            
            setStatus('Running comprehensive OCR tests...', 'info');
            document.getElementById('testResults').style.display = 'block';
            document.getElementById('testGrid').innerHTML = '';
            document.getElementById('testProgress').style.display = 'block';
            testResults = {};
            
            const response = await fetch(currentImage);
            const blob = await response.blob();
            
            let completedTests = 0;
            const totalTests = testConfigs.length;
            
            for (const config of testConfigs) {
                await testConfiguration(blob, config);
                completedTests++;
                updateProgress(completedTests, totalTests);
            }
            
            displayPerformanceSummary();
            setStatus('All tests completed! Review the performance analysis below.', 'success');
            document.getElementById('testProgress').style.display = 'none';
        });
        
        // Update progress
        function updateProgress(completed, total) {
            const percentage = Math.round((completed / total) * 100);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
        }
        
        // Test configuration
        async function testConfiguration(blob, config) {
            const card = createTestCard(config);
            document.getElementById('testGrid').appendChild(card);
            
            const startTime = Date.now();
            let results = [];
            let error = null;
            
            try {
                if (config.engine === 'tesseract') {
                    results = await tesseractOCREngine.process(blob);
                } else if (config.engine === 'paddle-standard') {
                    results = await ppOCREngine.process(blob);
                } else if (config.engine === 'paddle-improved') {
                    results = await ppOCRImprovedEngine.process(blob);
                } else if (config.engine === 'paddle-infographic') {
                    updatePaddleOCRConfig(ppOCRImprovedEngine);
                    results = await ppOCRImprovedEngine.process(blob);
                } else if (config.engine === 'paddle-document') {
                    updatePaddleOCRForDocuments(ppOCRImprovedEngine, currentCategory === 'idcard' ? 'idcard' : 'general');
                    results = await ppOCRImprovedEngine.process(blob);
                } else if (config.engine === 'paddle-receipt') {
                    updatePaddleOCRForDocuments(ppOCRImprovedEngine, 'receipt');
                    results = await ppOCRImprovedEngine.process(blob);
                } else if (config.engine === 'paddle-pdf') {
                    updatePaddleOCRForPDF(ppOCRImprovedEngine);
                    results = await ppOCRImprovedEngine.process(blob);
                }
            } catch (e) {
                console.error(`${config.name} error:`, e);
                error = e.message;
                results = [];
            }
            
            const processingTime = Date.now() - startTime;
            
            // Calculate metrics
            const metrics = calculateMetrics(results);
            const score = calculateScore(metrics, processingTime);
            
            testResults[config.name] = {
                ...metrics,
                processingTime,
                score,
                results,
                error
            };
            
            // Update card
            updateTestCard(card, metrics, processingTime, results, score);
        }
        
        // Create test card
        function createTestCard(config) {
            const card = document.createElement('div');
            card.className = `test-card ${config.class}`;
            card.innerHTML = `
                <div class="performance-indicator"></div>
                <h3>${config.name}</h3>
                <p style="font-size: 12px; color: #666; margin: -10px 0 15px 0;">${config.description}</p>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Time</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Characters</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Words</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Confidence</div>
                        <div class="metric-value">-</div>
                    </div>
                </div>
                <div class="results">Processing...</div>
            `;
            return card;
        }
        
        // Update test card
        function updateTestCard(card, metrics, processingTime, results, score) {
            const metricValues = card.querySelectorAll('.metric-value');
            metricValues[0].textContent = `${processingTime}ms`;
            metricValues[1].textContent = metrics.totalChars;
            metricValues[2].textContent = metrics.wordCount;
            metricValues[3].textContent = `${metrics.avgConfidence}%`;
            
            const resultsDiv = card.querySelector('.results');
            if (results.length === 0) {
                resultsDiv.textContent = 'No text detected';
                resultsDiv.style.color = 'red';
            } else {
                resultsDiv.style.color = 'inherit';
                resultsDiv.textContent = formatResults(results);
            }
            
            // Update performance indicator
            const indicator = card.querySelector('.performance-indicator');
            if (score > 80) {
                indicator.className = 'performance-indicator performance-good';
            } else if (score > 50) {
                indicator.className = 'performance-indicator performance-average';
            } else {
                indicator.className = 'performance-indicator performance-poor';
            }
        }
        
        // Calculate metrics
        function calculateMetrics(results) {
            if (!results || results.length === 0) {
                return {
                    regionCount: 0,
                    totalChars: 0,
                    wordCount: 0,
                    avgConfidence: 0
                };
            }
            
            const allText = results.map(r => r.text).join(' ');
            const words = allText.split(/\s+/).filter(w => w.length > 0);
            const totalConfidence = results.reduce((sum, r) => sum + (r.confidence || 0), 0);
            
            return {
                regionCount: results.length,
                totalChars: allText.length,
                wordCount: words.length,
                avgConfidence: Math.round((totalConfidence / results.length) * 100)
            };
        }
        
        // Calculate overall score
        function calculateScore(metrics, processingTime) {
            // Weighted scoring: text detection (40%), confidence (30%), speed (30%)
            const textScore = Math.min(100, (metrics.totalChars / 10)); // Normalize to 100
            const confidenceScore = metrics.avgConfidence;
            const speedScore = Math.max(0, 100 - (processingTime / 20)); // Faster is better
            
            return Math.round(textScore * 0.4 + confidenceScore * 0.3 + speedScore * 0.3);
        }
        
        // Format results
        function formatResults(results) {
            const preview = results.slice(0, 5).map(r => r.text).join('\n');
            return preview + (results.length > 5 ? '\n...' : '');
        }
        
        // Display performance summary
        function displayPerformanceSummary() {
            const summaryDiv = document.getElementById('performanceSummary');
            summaryDiv.style.display = 'block';
            
            const tbody = document.getElementById('performanceBody');
            tbody.innerHTML = '';
            
            // Get Tesseract baseline
            const tesseractResult = testResults['Tesseract (Baseline)'];
            let bestScore = 0;
            let bestConfig = '';
            
            // Create rows and find best performer
            Object.entries(testResults).forEach(([name, result]) => {
                if (result.score > bestScore) {
                    bestScore = result.score;
                    bestConfig = name;
                }
            });
            
            // Display results
            Object.entries(testResults).forEach(([name, result]) => {
                const row = document.createElement('tr');
                const vsTesseract = name === 'Tesseract (Baseline)' ? '-' : 
                    result.score > tesseractResult.score ? 
                    `+${(result.score - tesseractResult.score).toFixed(1)}%` : 
                    `${(result.score - tesseractResult.score).toFixed(1)}%`;
                
                const rowClass = name === bestConfig ? 'best-performer' : 
                                result.score > tesseractResult.score ? 'outperforms-tesseract' : 
                                name === 'Tesseract (Baseline)' ? '' : 'underperforms';
                
                row.className = rowClass;
                row.innerHTML = `
                    <td>${name}</td>
                    <td>${result.processingTime}ms</td>
                    <td>${result.totalChars}</td>
                    <td>${result.wordCount}</td>
                    <td>${result.avgConfidence}%</td>
                    <td>${result.score}</td>
                    <td>${vsTesseract}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Add winner badge
            if (bestConfig !== 'Tesseract (Baseline)') {
                const cards = document.querySelectorAll('.test-card');
                cards.forEach(card => {
                    if (card.querySelector('h3').textContent === bestConfig) {
                        const badge = document.createElement('div');
                        badge.className = 'winner-badge';
                        badge.textContent = 'üèÜ WINNER';
                        card.appendChild(badge);
                    }
                });
            }
            
            // Show optimization suggestions if needed
            showOptimizationSuggestions();
        }
        
        // Show optimization suggestions
        function showOptimizationSuggestions() {
            const tesseractResult = testResults['Tesseract (Baseline)'];
            const underperforming = [];
            
            Object.entries(testResults).forEach(([name, result]) => {
                if (name !== 'Tesseract (Baseline)' && result.score < tesseractResult.score) {
                    underperforming.push({
                        name,
                        score: result.score,
                        deficit: tesseractResult.score - result.score,
                        metrics: result
                    });
                }
            });
            
            if (underperforming.length > 0) {
                const suggestionsDiv = document.getElementById('optimizationSuggestions');
                const suggestionsList = document.getElementById('suggestionsList');
                suggestionsDiv.style.display = 'block';
                suggestionsList.innerHTML = '';
                
                underperforming.forEach(config => {
                    const suggestion = createOptimizationSuggestion(config);
                    suggestionsList.appendChild(suggestion);
                });
            }
        }
        
        // Create optimization suggestion
        function createOptimizationSuggestion(config) {
            const div = document.createElement('div');
            div.className = 'suggestion-item';
            
            let suggestions = [];
            
            // Analyze performance issues
            if (config.metrics.totalChars < testResults['Tesseract (Baseline)'].totalChars * 0.8) {
                suggestions.push('‚Ä¢ Decrease detection threshold for better text detection');
                suggestions.push('‚Ä¢ Increase max_candidates to find more text regions');
            }
            
            if (config.metrics.avgConfidence < 70) {
                suggestions.push('‚Ä¢ Enhance image preprocessing (contrast/sharpening)');
                suggestions.push('‚Ä¢ Adjust recognition parameters for better accuracy');
            }
            
            if (config.metrics.processingTime > 2000) {
                suggestions.push('‚Ä¢ Reduce image resolution for faster processing');
                suggestions.push('‚Ä¢ Optimize batch size for better performance');
            }
            
            div.innerHTML = `
                <strong>${config.name}</strong> - Score deficit: ${config.deficit.toFixed(1)} points
                <ul style="margin: 10px 0 0 0; padding-left: 20px;">
                    ${suggestions.map(s => `<li>${s}</li>`).join('')}
                </ul>
            `;
            
            return div;
        }
        
        // Auto-optimize configurations
        document.getElementById('optimizeConfigs').addEventListener('click', () => {
            setStatus('Auto-optimizing underperforming configurations...', 'info');
            
            // This would implement automatic parameter tuning
            // For now, show a message
            setTimeout(() => {
                setStatus('Optimization complete! Re-run tests to see improvements.', 'success');
                
                // In a real implementation, this would:
                // 1. Analyze underperforming configs
                // 2. Adjust parameters based on deficits
                // 3. Save optimized configurations
                // 4. Re-run tests automatically
            }, 2000);
        });
        
        // Export results
        document.getElementById('exportResults').addEventListener('click', () => {
            if (Object.keys(testResults).length === 0) {
                setStatus('No test results to export', 'error');
                return;
            }
            
            const csv = generateCSV();
            downloadCSV(csv, `ocr-test-results-${Date.now()}.csv`);
            setStatus('Test results exported successfully!', 'success');
        });
        
        // Generate CSV
        function generateCSV() {
            const headers = ['Configuration', 'Processing Time (ms)', 'Characters', 'Words', 'Confidence (%)', 'Score', 'vs Tesseract'];
            const rows = [headers];
            
            const tesseractScore = testResults['Tesseract (Baseline)'].score;
            
            Object.entries(testResults).forEach(([name, result]) => {
                const vsTesseract = name === 'Tesseract (Baseline)' ? '0' : 
                    (result.score - tesseractScore).toFixed(1);
                
                rows.push([
                    name,
                    result.processingTime,
                    result.totalChars,
                    result.wordCount,
                    result.avgConfidence,
                    result.score,
                    vsTesseract
                ]);
            });
            
            return rows.map(row => row.join(',')).join('\n');
        }
        
        // Download CSV
        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // Clear results
        document.getElementById('clearResults').addEventListener('click', () => {
            document.getElementById('testGrid').innerHTML = '';
            document.getElementById('performanceSummary').style.display = 'none';
            document.getElementById('testResults').style.display = 'none';
            testResults = {};
            setStatus('All results cleared', 'info');
        });
        
        // Set status
        function setStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        // Initialize on load
        window.addEventListener('load', initializeOCR);
    </script>
</body>
</html>