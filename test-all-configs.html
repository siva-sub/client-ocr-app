<!DOCTYPE html>
<html>
<head>
    <title>OCR Configuration Test - All Modes vs Tesseract</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1800px;
            margin: 0 auto;
            background: #f5f5f5;
        }
        .header {
            background: #2196F3;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .test-card {
            background: white;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-card h3 {
            margin-top: 0;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .test-card.tesseract h3 { background: #4CAF50; color: white; }
        .test-card.standard h3 { background: #FF9800; color: white; }
        .test-card.infographic h3 { background: #9C27B0; color: white; }
        .test-card.document h3 { background: #2196F3; color: white; }
        .test-card.receipt h3 { background: #F44336; color: white; }
        
        .results {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .metric {
            text-align: center;
        }
        .metric-label {
            font-size: 12px;
            color: #666;
        }
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .info { background: #d1ecf1; color: #0c5460; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        #preview {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 10px 0;
        }
        .image-section {
            text-align: center;
            margin: 20px 0;
        }
        .summary {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .comparison-table th {
            background: #f8f9fa;
            font-weight: bold;
        }
        .best-score {
            background: #d4edda;
            font-weight: bold;
        }
        .test-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .test-image-btn {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .test-image-btn:hover {
            background: #5a6268;
        }
        .test-image-btn.active {
            background: #28a745;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¨ OCR Configuration Tester</h1>
        <p>Test all OCR configurations against Tesseract baseline to ensure optimal performance</p>
    </div>
    
    <div class="controls">
        <h3>Test Images</h3>
        <div class="test-buttons">
            <button class="test-image-btn" onclick="loadTestImage('infographic')">Load Infographic Sample</button>
            <button class="test-image-btn" onclick="loadTestImage('document')">Load Document Sample</button>
            <button class="test-image-btn" onclick="loadTestImage('idcard')">Load ID Card Sample</button>
            <button class="test-image-btn" onclick="loadTestImage('receipt')">Load Receipt Sample</button>
        </div>
        
        <h3>Or Upload Your Own Image</h3>
        <input type="file" id="fileInput" accept="image/*">
        
        <h3>Run Tests</h3>
        <button id="runAllTests" disabled>üöÄ Run All Configuration Tests</button>
        <button id="clearResults">üóëÔ∏è Clear Results</button>
    </div>
    
    <div id="status" class="status info">Initializing OCR engines...</div>
    
    <div class="image-section">
        <img id="preview" style="display: none;" />
        <div id="imageInfo"></div>
    </div>
    
    <div id="testResults" style="display: none;">
        <div class="test-grid" id="testGrid"></div>
        
        <div class="summary" id="summary" style="display: none;">
            <h3>üìä Test Summary</h3>
            <table class="comparison-table" id="comparisonTable">
                <thead>
                    <tr>
                        <th>Configuration</th>
                        <th>Processing Time (ms)</th>
                        <th>Regions Detected</th>
                        <th>Total Characters</th>
                        <th>Confidence Score</th>
                    </tr>
                </thead>
                <tbody id="comparisonBody"></tbody>
            </table>
            <div id="recommendation" style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 4px;"></div>
        </div>
    </div>

    <script type="module">
        import { ppOCRImprovedEngine } from './src/ppocr-improved-engine.js';
        import { ppOCREngine } from './src/ppocr-onnx-engine.js';
        import { tesseractOCREngine } from './src/tesseract-ocr-engine.js';
        import { INFOGRAPHIC_OCR_CONFIG, updatePaddleOCRConfig } from './src/infographic-ocr-config.js';
        import { 
            DOCUMENT_OCR_CONFIG, 
            RECEIPT_OCR_CONFIG,
            updatePaddleOCRForDocuments,
            extractIDCardFields,
            extractReceiptFields
        } from './src/document-ocr-config.js';
        import { PDF_OCR_CONFIG, updatePaddleOCRForPDF } from './src/pdf-ocr-config.js';
        
        let currentImage = null;
        let testResults = {};
        let isInitialized = false;
        
        // Test image samples (base64 placeholders)
        const testImages = {
            infographic: {
                description: 'Complex infographic with multiple text regions',
                type: 'infographic'
            },
            document: {
                description: 'Official document with structured text',
                type: 'document'
            },
            idcard: {
                description: 'ID card with personal information',
                type: 'idcard'
            },
            receipt: {
                description: 'Receipt with prices and items',
                type: 'receipt'
            }
        };
        
        // Initialize OCR engines
        async function initializeOCR() {
            setStatus('Initializing OCR engines...', 'info');
            try {
                await Promise.all([
                    ppOCRImprovedEngine.initialize((progress) => {
                        console.log('PaddleOCR Improved:', progress.message);
                    }),
                    ppOCREngine.initialize((progress) => {
                        console.log('PaddleOCR Standard:', progress.message);
                    }),
                    tesseractOCREngine.initialize((progress) => {
                        console.log('Tesseract:', progress.message);
                    })
                ]);
                isInitialized = true;
                setStatus('OCR engines ready! Upload an image or select a test image.', 'success');
                document.getElementById('runAllTests').disabled = false;
            } catch (error) {
                setStatus('Failed to initialize OCR: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        // Load test image
        window.loadTestImage = function(type) {
            document.querySelectorAll('.test-image-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            setStatus(`Test image type selected: ${type}. Please upload an actual ${type} image to test.`, 'info');
            document.getElementById('imageInfo').textContent = `Ready to test ${type} configuration`;
        };
        
        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                loadFile(file);
            }
        });
        
        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImage = e.target.result;
                document.getElementById('preview').src = currentImage;
                document.getElementById('preview').style.display = 'block';
                
                const img = new Image();
                img.onload = () => {
                    document.getElementById('imageInfo').textContent = 
                        `${file.name} - ${img.width}x${img.height} pixels`;
                };
                img.src = currentImage;
                
                setStatus('Image loaded. Click "Run All Configuration Tests" to begin.', 'success');
                document.getElementById('runAllTests').disabled = false;
            };
            reader.readAsDataURL(file);
        }
        
        // Run all tests
        document.getElementById('runAllTests').addEventListener('click', async () => {
            if (!currentImage) {
                setStatus('Please upload an image first', 'error');
                return;
            }
            
            if (!isInitialized) {
                setStatus('OCR engines not initialized yet', 'error');
                return;
            }
            
            setStatus('Running all configuration tests...', 'info');
            document.getElementById('runAllTests').disabled = true;
            document.getElementById('testResults').style.display = 'block';
            document.getElementById('testGrid').innerHTML = '';
            testResults = {};
            
            try {
                const response = await fetch(currentImage);
                const blob = await response.blob();
                
                // Test configurations
                const configs = [
                    { name: 'Tesseract (Baseline)', engine: 'tesseract', class: 'tesseract' },
                    { name: 'PaddleOCR Standard', engine: 'paddle', mode: 'standard', class: 'standard' },
                    { name: 'PaddleOCR Improved', engine: 'paddle', mode: 'improved', class: 'standard' },
                    { name: 'PaddleOCR Infographic', engine: 'paddle', mode: 'infographic', class: 'infographic' },
                    { name: 'PaddleOCR Document', engine: 'paddle', mode: 'document', class: 'document' },
                    { name: 'PaddleOCR Receipt', engine: 'paddle', mode: 'receipt', class: 'receipt' },
                    { name: 'PaddleOCR PDF', engine: 'paddle', mode: 'pdf', class: 'receipt' }
                ];
                
                for (const config of configs) {
                    await testConfiguration(blob, config);
                }
                
                displaySummary();
                setStatus('All tests completed!', 'success');
            } catch (error) {
                setStatus('Testing failed: ' + error.message, 'error');
                console.error(error);
            } finally {
                document.getElementById('runAllTests').disabled = false;
            }
        });
        
        // Test a single configuration
        async function testConfiguration(blob, config) {
            const card = createTestCard(config.name, config.class);
            document.getElementById('testGrid').appendChild(card);
            
            const startTime = Date.now();
            let results = [];
            
            try {
                if (config.engine === 'tesseract') {
                    results = await tesseractOCREngine.process(blob);
                } else {
                    // Select engine and apply configuration
                    let engine = ppOCRImprovedEngine;
                    
                    if (config.mode === 'standard') {
                        engine = ppOCREngine;
                    } else if (config.mode === 'improved') {
                        engine = ppOCRImprovedEngine;
                    } else if (config.mode === 'infographic') {
                        updatePaddleOCRConfig(ppOCRImprovedEngine);
                    } else if (config.mode === 'document') {
                        updatePaddleOCRForDocuments(ppOCRImprovedEngine, 'general');
                    } else if (config.mode === 'receipt') {
                        updatePaddleOCRForDocuments(ppOCRImprovedEngine, 'receipt');
                    } else if (config.mode === 'pdf') {
                        updatePaddleOCRForPDF(ppOCRImprovedEngine);
                    }
                    
                    results = await engine.process(blob);
                }
            } catch (error) {
                console.error(`${config.name} error:`, error);
                results = [];
            }
            
            const processingTime = Date.now() - startTime;
            
            // Calculate metrics
            const metrics = calculateMetrics(results);
            testResults[config.name] = {
                ...metrics,
                processingTime,
                results
            };
            
            // Update card
            updateTestCard(card, metrics, processingTime, results);
        }
        
        // Create test card
        function createTestCard(name, className) {
            const card = document.createElement('div');
            card.className = `test-card ${className}`;
            card.innerHTML = `
                <h3>${name}</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Processing Time</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Regions</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Characters</div>
                        <div class="metric-value">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Avg Confidence</div>
                        <div class="metric-value">-</div>
                    </div>
                </div>
                <div class="results">Processing...</div>
            `;
            return card;
        }
        
        // Update test card with results
        function updateTestCard(card, metrics, processingTime, results) {
            const metricValues = card.querySelectorAll('.metric-value');
            metricValues[0].textContent = `${processingTime}ms`;
            metricValues[1].textContent = metrics.regionCount;
            metricValues[2].textContent = metrics.totalChars;
            metricValues[3].textContent = `${metrics.avgConfidence}%`;
            
            const resultsDiv = card.querySelector('.results');
            if (results.length === 0) {
                resultsDiv.textContent = 'No text detected';
                resultsDiv.style.color = 'red';
            } else {
                resultsDiv.style.color = 'inherit';
                resultsDiv.textContent = formatResults(results);
            }
        }
        
        // Calculate metrics
        function calculateMetrics(results) {
            if (!results || results.length === 0) {
                return {
                    regionCount: 0,
                    totalChars: 0,
                    avgConfidence: 0
                };
            }
            
            const totalChars = results.reduce((sum, r) => sum + (r.text || '').length, 0);
            const totalConfidence = results.reduce((sum, r) => sum + (r.confidence || 0), 0);
            const avgConfidence = Math.round((totalConfidence / results.length) * 100);
            
            return {
                regionCount: results.length,
                totalChars,
                avgConfidence
            };
        }
        
        // Format results for display
        function formatResults(results) {
            if (!results || results.length === 0) return 'No results';
            
            // Sort by position
            const sorted = [...results].sort((a, b) => {
                const aY = a.box ? Math.min(...a.box.map(p => p[1])) : a.bbox ? a.bbox.y0 : 0;
                const bY = b.box ? Math.min(...b.box.map(p => p[1])) : b.bbox ? b.bbox.y0 : 0;
                return aY - bY;
            });
            
            let output = '=== Detected Text ===\n';
            sorted.forEach((result, index) => {
                const confidence = result.confidence ? `(${(result.confidence * 100).toFixed(1)}%)` : '';
                output += `[${index + 1}] ${result.text} ${confidence}\n`;
            });
            
            return output;
        }
        
        // Display summary
        function displaySummary() {
            const summaryDiv = document.getElementById('summary');
            summaryDiv.style.display = 'block';
            
            const tbody = document.getElementById('comparisonBody');
            tbody.innerHTML = '';
            
            // Find best values
            let bestTime = Infinity;
            let bestRegions = 0;
            let bestChars = 0;
            let bestConfidence = 0;
            
            Object.values(testResults).forEach(result => {
                if (result.processingTime < bestTime) bestTime = result.processingTime;
                if (result.regionCount > bestRegions) bestRegions = result.regionCount;
                if (result.totalChars > bestChars) bestChars = result.totalChars;
                if (result.avgConfidence > bestConfidence) bestConfidence = result.avgConfidence;
            });
            
            // Create rows
            Object.entries(testResults).forEach(([name, result]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${name}</td>
                    <td class="${result.processingTime === bestTime ? 'best-score' : ''}">${result.processingTime}ms</td>
                    <td class="${result.regionCount === bestRegions ? 'best-score' : ''}">${result.regionCount}</td>
                    <td class="${result.totalChars === bestChars ? 'best-score' : ''}">${result.totalChars}</td>
                    <td class="${result.avgConfidence === bestConfidence ? 'best-score' : ''}">${result.avgConfidence}%</td>
                `;
                tbody.appendChild(row);
            });
            
            // Generate recommendation
            generateRecommendation();
        }
        
        // Generate recommendation
        function generateRecommendation() {
            const recDiv = document.getElementById('recommendation');
            
            // Analyze results
            const tesseractResult = testResults['Tesseract (Baseline)'];
            let bestPaddleConfig = null;
            let bestPaddleScore = 0;
            
            ['PaddleOCR Standard', 'PaddleOCR Infographic', 'PaddleOCR Document', 'PaddleOCR Receipt'].forEach(name => {
                const result = testResults[name];
                if (result) {
                    // Score based on character detection and confidence
                    const score = (result.totalChars * 2) + result.avgConfidence - (result.processingTime / 10);
                    if (score > bestPaddleScore) {
                        bestPaddleScore = score;
                        bestPaddleConfig = name;
                    }
                }
            });
            
            let recommendation = '<h4>üí° Recommendation:</h4>';
            
            if (tesseractResult && tesseractResult.totalChars > 0) {
                const paddleResult = testResults[bestPaddleConfig];
                const charDiff = paddleResult ? ((paddleResult.totalChars - tesseractResult.totalChars) / tesseractResult.totalChars * 100).toFixed(1) : 0;
                
                if (paddleResult && paddleResult.totalChars > tesseractResult.totalChars * 1.1) {
                    recommendation += `<p><strong>${bestPaddleConfig}</strong> detected ${charDiff}% more text than Tesseract. `;
                    recommendation += `Consider using this configuration for better text detection.</p>`;
                } else if (tesseractResult.avgConfidence > 80) {
                    recommendation += `<p><strong>Tesseract</strong> provides reliable results with ${tesseractResult.avgConfidence}% confidence. `;
                    recommendation += `It's recommended for general use.</p>`;
                } else {
                    recommendation += `<p>Both engines show similar performance. Choose based on your specific needs:</p>`;
                    recommendation += `<ul>`;
                    recommendation += `<li><strong>Tesseract:</strong> Better for English text and standard documents</li>`;
                    recommendation += `<li><strong>${bestPaddleConfig}:</strong> Better for complex layouts and multi-language support</li>`;
                    recommendation += `</ul>`;
                }
            }
            
            recDiv.innerHTML = recommendation;
        }
        
        // Clear results
        document.getElementById('clearResults').addEventListener('click', () => {
            document.getElementById('testGrid').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            document.getElementById('testResults').style.display = 'none';
            testResults = {};
            setStatus('Results cleared', 'info');
        });
        
        // Set status
        function setStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        // Initialize on load
        window.addEventListener('load', initializeOCR);
    </script>
</body>
</html>